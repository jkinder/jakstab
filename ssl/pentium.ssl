# pentium.ssl - This file is part of the Jakstab project.
# Copyright 2007-2015 Johannes Kinder <jk@jakstab.org>
# Copyright 2001, Sun Microsystems, Inc
# Copyright 1998-2001, The University of Queensland
#
# This code is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License version 2 only, as
# published by the Free Software Foundation.
#
# This code is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# version 2 for more details (a copy is included in the LICENSE file that
# accompanied this code).
#
# You should have received a copy of the GNU General Public License version
# 2 along with this work; if not, see <http://www.gnu.org/licenses/>.
#

#
# A semantic description of the IA-32 architecture
#

# Constants defined in hexadecimal (modelling manual) 
MAX8BITS  := 0xFF;
MAX16BITS := 0xFFFF;
MAX32BITS := 0xFFFFFFFF;
# MAX64BITS := 0xFFFFFFFFFFFFFFFF; used nowhere, overflows the parser
MAX8POS   := 0x7F;
MAX8NEG   := 0x80;
MAX16POS  := 0x7FFF;
MAX16NEG  := 0x8000;
MAX32POS  := 0x7FFFFFFF;
MAX32NEG  := 0x80000000;
ADDRESSBITS := 32;


# 
# Only proper registers are defined in SSL, temporary variables 
# are declared implicitly (types are now consistent).
#  8 bit: tmpb
# 16 bit: tmph
# 32 bit: tmp1 - tmp5
# 64 bit: tmpl
#

INTEGER
[ %eax, %ecx, %edx, %ebx,
  %esp, %ebp, %esi, %edi ][32] -> 24..31,
%ax[16] -> 0 SHARES %eax@[0..15],
%cx[16] -> 1 SHARES %ecx@[0..15],
%dx[16] -> 2 SHARES %edx@[0..15],
%bx[16] -> 3 SHARES %ebx@[0..15],
%sp[16] -> 4 SHARES %esp@[0..15],
%bp[16] -> 5 SHARES %ebp@[0..15],
%si[16] -> 6 SHARES %esi@[0..15],
%di[16] -> 7 SHARES %edi@[0..15],
%al[8]  -> 8 SHARES %ax@[0..7],  # Changed to refer to the 16-bit registers for
%cl[8]  -> 9 SHARES %cx@[0..7],  # easier implementation of the covered - coveredby
%dl[8]  -> 10 SHARES %dx@[0..7], # relation in ExpressionFactory
%bl[8]  -> 11 SHARES %bx@[0..7],
%ah[8]  -> 12 SHARES %ax@[8..15],
%ch[8]  -> 13 SHARES %cx@[8..15],
%dh[8]  -> 14 SHARES %dx@[8..15],
%bh[8]  -> 15 SHARES %bx@[8..15],
%es[16]  -> 16,
%cs[16]  -> 17,
%ss[16]  -> 18,
%ds[16]  -> 19,
%fs[16]  -> 20,
%gs[16] -> 21,
[ %cr0, %cr2, %cr3, %cr4 ][32] -> 22..25,
%pc[32] -> -1,
[ %SF, %ZF, %AF, %PF,
  %CF, %OF, %DF, %IF,
  %FLF, ## -JK removed %FP - what should that be?
  %C1, %C2, %FZF ][1] -> -1;

FLOAT
[ %st0, %st1,        # stack head, stack neck
  %st2, %st3, %st4, %st5, %st6, %st7 ][80] -> 34..41;

INTEGER
%fsw[16] -> 42, #Float status word(16 Bit register Containing information about
                #The state of the FPU.  stores the top of stack pointer
                #information aswell as the exception flags and stack fault
                #information)

%fstp[8] -> 43, #Floating point stack pointer.  Holds the top of stack pointer.
                #NB is bits 11->13 inclusive of the fsw(defined above).

%fcw[16] -> 44, #Floating point Control Word (16 bit register holding
                #information such as the infinity control, rounding control,
                #precision control and exception masks.
[%xmm0, %xmm1, %xmm2, %xmm3, %xmm4, %xmm5, %xmm6, %xmm7][128] -> 45..53,
%mxcsr[32] -> 54;
                
                
undefineflags( ) {
		*1* %CF := nondet(1)
		*1* %OF := nondet(1)
		*1* %SF := nondet(1)
		*1* %ZF := nondet(1)
};

# JK: Add, sub, and logical flag updates are now generic

ADDFLAGS8(op1, op2, result)  {
			addflags_generic(op1, op2, result)
#            *1* %CF := ((op1@[7:7]) & (op2@[7:7]))
#                        | (~(result@[7:7]) & ((op1@[7:7]) | (op2@[7:7])))
#            *1* %OF := ((op1@[7:7]) & (op2@[7:7]) & ~(result@[7:7]))
#                        | (~(op1@[7:7]) & ~(op2@[7:7]) & (result@[7:7]))
#            *1* %SF := result@[7:7]
#            *1* %ZF := [result = 0?1:0]
};

ADDFLAGS16(op1, op2, result)  {
			addflags_generic(op1, op2, result)
#            *1* %CF := ((op1@[15:15]) & (op2@[15:15]))
#                        | (~(result@[15:15]) & ((op1@[15:15]) | (op2@[15:15])))
#            *1* %OF := ((op1@[15:15]) & (op2@[15:15]) & ~(result@[15:15]))
#                        | (~(op1@[15:15]) & ~(op2@[15:15]) & (result@[15:15]))
#            *1* %SF := result@[15:15]
#            *1* %ZF := [result = 0?1:0]
};

ADDFLAGS32(op1, op2, result)  {
			addflags_generic(op1, op2, result)
#            *1* %CF := ((op1@[31:31]) & (op2@[31:31]))
#                        | (~(result@[31:31]) & ((op1@[31:31]) | (op2@[31:31])))
#            *1* %OF := ((op1@[31:31]) & (op2@[31:31]) & ~(result@[31:31]))
#                        | (~(op1@[31:31]) & ~(op2@[31:31]) & (result@[31:31]))
#            *1* %SF := result@[31:31]
#            *1* %ZF := [result = 0?1:0]
};

addflags_generic(op1, op2, result)  {
            *1* %CF := ((op1 < 0) & (op2 < 0))
                        | ((result >= 0) & ((op1 < 0) | (op2 < 0)))
            *1* %OF := ((op1 < 0) & (op2 < 0) & (result >= 0))
                        | ((op1 >= 0) & (op2 >= 0) & (result < 0))
            *1* %SF := (result < 0)
            *1* %ZF := (result = 0)
};

SUBFLAGS8(op1, op2, result)  {
			 subflags_generic(op1, op2, result)
#            *1* %CF := (~(op1@[7:7]) & (op2@[7:7]))
#                        | ((result@[7:7]) & (~(op1@[7:7]) | (op2@[7:7])))
#            *1* %OF := ((op1@[7:7]) & ~(op2@[7:7]) & ~(result@[7:7]))
#                        | (~(op1@[7:7]) & (op2@[7:7]) & (result@[7:7]))
#            *1* %SF := result@[7:7]
#            *1* %ZF := [result = 0?1:0]
};

SUBFLAGS16(op1, op2, result)  {
			 subflags_generic(op1, op2, result)
#            *1* %CF := (~(op1@[15:15]) & (op2@[15:15]))
#                        | ((result@[15:15]) & (~(op1@[15:15]) | (op2@[15:15])))
#            *1* %OF := ((op1@[15:15]) & ~(op2@[15:15]) & ~(result@[15:15]))
#                        | (~(op1@[15:15]) & (op2@[15:15]) & (result@[15:15]))
#            *1* %SF := result@[15:15]
#            *1* %ZF := [result = 0?1:0]
};

SUBFLAGS32(op1, op2, result)  {
			 subflags_generic(op1, op2, result)
#            *1* %CF := (~(op1@[31:31]) & (op2@[31:31]))
#                        | ((result@[31:31]) & (~(op1@[31:31]) | (op2@[31:31])))
#            *1* %OF := ((op1@[31:31]) & ~(op2@[31:31]) & ~(result@[31:31]))
#                        | (~(op1@[31:31]) & (op2@[31:31]) & (result@[31:31]))
#            *1* %SF := result@[31:31]
#            *1* %ZF := [result = 0?1:0]
};

subflags_generic(op1, op2, result)  {
# Use unsigned comparison now, since CF is only used by unsigned conditional jumps (JA, JB, etc.)
#            *1* %CF := ((op1 >= 0) & (op2 < 0))
#                        | ((result < 0) & ((op1 >= 0) | (op2 < 0)))
			*1* %CF := (op1 <u op2)
            *1* %OF := ((op1 < 0) & (op2 >= 0) & (result > 0)) 
                         | ((op1 >= 0) & (op2 < 0) & (result < 0))
            *1* %SF := (result < 0)
#            *1* %ZF := (result = 0)
# 5.7.2012, JK: The <= (>=) in the OF expression can be < (>), since the equal zero
#               cases will never make the result flip its sign. The result can also
#               never be zero with OF set
# 12.8.: "-" is a bitvector operation, cannot simplify op1-op2 >= 0 to op1 >= op2 !
#            *1* %OF := ((op1 < 0) & (op2 >= 0) & (op1 >= op2))
#                        | ((op1 >= 0) & (op2 < 0) & (op1 >= op2))
#            *1* %SF := (op1 < op2)
            *1* %ZF := (op1 = op2)
};

SUBFLAGSFL(op1, op2) {
			*1* %CF := op1 < op2
			*1* %ZF := op1 = op2
};

LOGICALFLAGS8(result)  {
			logicalflags_generic(result)
#            *1* %CF := 0
#            *1* %OF := 0
#            *1* %ZF := [result = 0?1:0]
#            *1* %SF := result@[7:7]
};

LOGICALFLAGS16(result)  {
			logicalflags_generic(result)
#            *1* %CF := 0
#            *1* %OF := 0
#            *1* %ZF := [result = 0?1:0]
#            *1* %SF := result@[15:15]
};

LOGICALFLAGS32(result)  {
			logicalflags_generic(result)
#            *1* %CF := 0
#            *1* %OF := 0
#            *1* %ZF := [result = 0?1:0]
#            *1* %SF := result@[31:31]
};

logicalflags_generic(result)  {
            *1* %CF := 0
            *1* %OF := 0
            *1* %ZF := (result = 0)
            *1* %SF := (result < 0)
};

IMULTFLAGS8(result)  {
			*1* %CF := [(sgnex(1,7,result@[7:7]) = result@[8:15])?0:1]
			*1* %OF := %CF
#            *1* %CF := [(result@[7:15] = 0) or (result@[7:15] = 1)?1:0]
#            *1* %OF := [(result@[7:15] = 0) or (result@[7:15] = 1)?1:0]
};

IMULTFLAGS16(result)  {
			*1* %CF := [(sgnex(1,15,result@[15:15]) = result@[16:31])?0:1]
			*1* %OF := %CF
#            *1* %CF := [(result@[15:31] = 0) or (result@[15:31] = 1)?1:0]
#            *1* %OF := [(result@[15:31] = 0) or (result@[15:31] = 1)?1:0]
};

IMULTFLAGS32(result)  {
			*1* %CF := [(sgnex(1,31,result@[31:31]) = result@[32:63])?0:1]
			*1* %OF := %CF
#            *1* %CF := [(result@[31:63] = 0) or (result@[31:63] = 1)?1:0]
#            *1* %OF := [(result@[31:63] = 0) or (result@[31:63] = 1)?1:0]
};

MULTFLAGS8(result)  {
            *1* %CF := [result@[8:15] = 0 ? 0:1]
            *1* %OF := %CF
};

MULTFLAGS16(result)  {
            *1* %CF := [result@[16:31] = 0 ? 0:1]
            *1* %OF := %CF
};

MULTFLAGS32(result)  {
            *1* %CF := [result@[32:63] = 0 ? 0:1]
            *1* %OF := %CF
};

ROLFLAGS8(result, op1, count)  {
            *1* %OF := [count = 1?(op1@[7:7]) ~= %CF:nondet(1)]
            *1* %CF := result@[7:7]
};

ROLFLAGS16(result, op1, count)  {
            *1* %OF := [count = 1?(op1@[15:15]) ~= %CF:nondet(1)]
            *1* %CF := result@[15:15]
};

ROLFLAGS32(result, op1, count)  {
            *1* %OF := [count = 1?(op1@[31:31]) ~= %CF:nondet(1)]
            *1* %CF := result@[31:31]
};

RORFLAGS8(result, op1, count)  {
            *1* %CF := result@[7:7]
            *1* %OF := [count = 1?(op1@[7:7]) ~= (op1@[6:6]):nondet(1)]
};

RORFLAGS16(result, op1, count)  {
            *1* %CF := result@[15:15]
            *1* %OF := [count = 1?(op1@[15:15]) ~= (op1@[14:14]):nondet(1)]
};

RORFLAGS32(result, op1, count)  {
            *1* %CF := result@[31:31]
            *1* %OF := [count = 1?(op1@[31:31]) ~= (op1@[30:30]):nondet(1)]
};

SALFLAGS8(result, op1, count)  {
            *1* %CF := op1@[(8 - count):(8 - count)]
            *1* %OF := [count = 1?(result@[7:7]) ~= %CF:nondet(1)]
};

SALFLAGS16(result, op1, count)  {
            *1* %CF := op1@[(16 - count):(16 - count)]
            *1* %OF := [count = 1?(result@[15:15]) ~= %CF:nondet(1)]
};

SALFLAGS32(result, op1, count)  {
            *1* %CF := op1@[(32 - count):(32 - count)]
            *1* %OF := [count = 1?(result@[31:31]) ~= %CF:nondet(1)]
};

SARFLAGS(result, op1, count)  {
            *1* %CF := op1@[(count - 1):(count - 1)]
            *1* %OF := [count = 1?0:nondet(1)]
};

SHRFLAGS8(result, op1, count)  {
            *1* %CF := op1@[(count - 1):(count - 1)]
            *1* %OF := [count = 1?(result@[7:7]) ~= %CF:nondet(1)]
};

SHRFLAGS16(result, op1, count)  {
            *1* %CF := op1@[(count - 1):(count - 1)]
            *1* %OF := [count = 1?(result@[15:15]) ~= %CF:nondet(1)]
};

SHRFLAGS32(result, op1, count)  {
            *1* %CF := op1@[(count - 1):(count - 1)]
            *1* %OF := [count = 1?(result@[31:31]) ~= %CF:nondet(1)]
};

SHLDFLAGS32(result, combine, count)  {
            *1* %CF := combine@[(32 - count):(32 - count)]
            *1* %OF := [count = 1?(result@[31:31]) ~= %CF:nondet(1)]
};

SHLDFLAGS64(result, combine, count)  {
            *1* %CF := combine@[(64 - count):(64 - count)]
            *1* %OF := [count = 1?(result@[63:63]) ~= %CF:nondet(1)]
};

SHRDFLAGS32(result, combine, count)  {
            *1* %CF := combine@[(count - 1):(count - 1)]
            *1* %OF := [count = 1?(result@[31:31]) ~= %CF:nondet(1)]
};

SHRDFLAGS64(result, combine, count)  {
            *1* %CF := combine@[(count - 1):(count - 1)]
            *1* %OF := [count = 1?(result@[63:63]) ~= %CF:nondet(1)]
};

SETFFLAGS(op1, op2)  {
            *1* %FZF := [(op1 = op2) ? 1 : 0]
            *1* %FLF := [(op1 < op2) ? 1 : 0]
            *1* %C2 := 0 # [ (op1 > op2) ? 1 : 0]
};

OP1 := { "+", "-" };
ARITB := { "ADDB", "SUBB" };
ARITW := { "ADDW", "SUBW" };
ARITL := { "ADDL", "SUBL" };

ARITB[IDX].IAL i8 
            *8* tmpb := %al
            *8* %al := %al OP1[IDX] i8;
ADDB.IAL   i8 ADDFLAGS8(tmpb, i8, %al);
SUBB.IAL   i8 SUBFLAGS8(tmpb, i8, %al);

ARITW[IDX].IAX i16 
            *16* tmph := %ax
            *16* %ax := %ax OP1[IDX] i16;
ADDW.IAX   i16 ADDFLAGS16(tmph, i16, %ax);
SUBW.IAX   i16 SUBFLAGS16(tmph, i16, %ax);

ARITL[IDX].IEAX i32 
            *32* tmp1 := %eax
            *32* %eax := %eax OP1[IDX] i32;
ADDL.IEAX   i32 ADDFLAGS32(tmp1, i32, %eax);
SUBL.IEAX   i32 SUBFLAGS32(tmp1, i32, %eax);

ARITL[IDX].ID modrm, i32 
            *32* tmp1 := modrm
            *32* modrm := modrm OP1[IDX] i32;
ADDL.ID   modrm, i32 ADDFLAGS32(tmp1, i32, modrm);
SUBL.ID   modrm, i32 SUBFLAGS32(tmp1, i32, modrm);

ARITW[IDX].IW modrm, i16 
            *16* tmph := modrm
            *16* modrm := modrm OP1[IDX] i16;
ADDW.IW   modrm, i16 ADDFLAGS16(tmph, i16, modrm);
SUBW.IW   modrm, i16 SUBFLAGS16(tmph, i16, modrm);

ARITB[IDX].IB modrm, i8 
            *8* tmpb := modrm
            *8* modrm := modrm OP1[IDX] i8;
ADDB.IB   modrm, i8 ADDFLAGS8(tmpb, i8, modrm);
SUBB.IB   modrm, i8 SUBFLAGS8(tmpb, i8, modrm);

# Lesser width immediate operands are always sign extended
ARITW[IDX].IBOW modrm, i8 
            *16* tmph := modrm
            *16* modrm := modrm OP1[IDX] sgnex(8,15,i8);
ADDW.IBOW   modrm, i8 ADDFLAGS16(tmph, sgnex(8,15,i8), modrm);
SUBW.IBOW   modrm, i8 SUBFLAGS16(tmph, sgnex(8,15,i8), modrm);

ARITL[IDX].IBOD modrm, i8 
            *32* tmp1 := modrm
            *32* modrm := modrm OP1[IDX] sgnex(8,31,i8);
ADDL.IBOD   modrm, i8 ADDFLAGS32(tmp1, sgnex(8,31,i8), modrm);
SUBL.IBOD   modrm, i8 SUBFLAGS32(tmp1, sgnex(8,31,i8), modrm);

ARITB[IDX].MRB modrm, reg8
            *8* tmpb := modrm
            *8* modrm := tmpb OP1[IDX] reg8;
ADDB.MRB   modrm, reg8 ADDFLAGS8(tmpb, reg8, modrm);
SUBB.MRB   modrm, reg8 SUBFLAGS8(tmpb, reg8, modrm);

ARITW[IDX].MROW modrm, reg16 
            *16* tmph := modrm
            *16* modrm := tmph OP1[IDX] reg16;
ADDW.MROW   modrm, reg16 ADDFLAGS16(tmph, reg16, modrm);
SUBW.MROW   modrm, reg16 SUBFLAGS16(tmph, reg16, modrm);

ARITL[IDX].MROD modrm, reg32 
            *32* tmp1 := modrm
            *32* modrm := modrm OP1[IDX] reg32;
ADDL.MROD   modrm, reg32 ADDFLAGS32(tmp1, reg32, modrm);
SUBL.MROD   modrm, reg32 SUBFLAGS32(tmp1, reg32, modrm);

ARITB[IDX].RMB reg8, modrm 
            *8* tmpb := reg8
            *8* reg8 := reg8 OP1[IDX] modrm{8};
ADDB.RMB   reg8, modrm ADDFLAGS8(tmpb, modrm{8}, reg8);
SUBB.RMB   reg8, modrm SUBFLAGS8(tmpb, modrm{8}, reg8);

ARITW[IDX].RMOW reg16, modrm 
            *16* tmph := reg16
            *16* reg16 := reg16 OP1[IDX] modrm{16};
ADDW.RMOW   reg16, modrm ADDFLAGS16(tmph, modrm{16}, reg16);
SUBW.RMOW   reg16, modrm SUBFLAGS16(tmph, modrm{16}, reg16);

ARITL[IDX].RMOD reg32, modrm 
            *32* tmp1 := reg32
            *32* reg32 := reg32 OP1[IDX] modrm;
ADDL.RMOD   reg32, modrm ADDFLAGS32(tmp1, modrm, reg32);
SUBL.RMOD   reg32, modrm SUBFLAGS32(tmp1, modrm, reg32);

# -JK Reversed bitrange order
BSWAP       reg32
            *32* tmp1 := zfill(8, 31, reg32@[24:31])
            *32* tmp2 := zfill(8, 31, reg32@[16:23])
            *32* tmp3 := zfill(8, 31, reg32@[8:15])
            *32* tmp4 := reg32 & 0xFF
            *32* reg32 := (tmp4 << 24) + (tmp3 << 16) + (tmp2 << 8) + tmp1;

CMPB.IAL   i8 
            *8* tmpb := %al - i8
            SUBFLAGS8(%al, i8, tmpb);

CMPW.IAX   i16 
            *16* tmph := %ax - i16
            SUBFLAGS16(%ax, i16, tmph);

CMPL.IEAX   i32 
            *32* tmp1 := %eax - i32
            SUBFLAGS32(%eax, i32, tmp1);

CMPL.ID   modrm, i32 
            *32* tmp1 := modrm{32} - i32
            SUBFLAGS32(modrm, i32, tmp1);

CMPW.IW   modrm, i16 
            *16* tmph := modrm{16} - i16
            SUBFLAGS16(modrm{16}, i16, tmph);

CMPB.IB   modrm, i8 
            *8* tmpb := modrm{8} - i8
            SUBFLAGS8(modrm{8}, i8, tmpb);

CMPB.MRB   modrm, reg8 
            *8* tmpb := modrm{8} - reg8
            SUBFLAGS8(modrm{8}, reg8, tmpb);

CMPB.RMB   reg8, modrm 
            *8* tmpb := reg8 - modrm{8}
            SUBFLAGS8(reg8, modrm{8}, tmpb);

CMPL.IBOD   modrm, i8 
            *32* tmp1 := modrm{32} - sgnex(8,31,i8)
            SUBFLAGS32(modrm{32}, sgnex(8,31,i8), tmp1);

CMPW.IBOW   modrm, i8 
            *16* tmph := modrm{16} - sgnex(8,15,i8)
            SUBFLAGS16(modrm{16}, sgnex(8,15,i8), tmph);

CMPW.MROW   modrm, reg16 
            *16* tmph := modrm{16} - reg16
            SUBFLAGS16(modrm{16}, reg16, tmph);

CMPL.MROD   modrm, reg32 
            *32* tmp1 := modrm{32} - reg32
            SUBFLAGS32(modrm{32}, reg32, tmp1);

CMPW.RMOW   reg16, modrm 
            *16* tmph := reg16 - modrm{16}
            SUBFLAGS16(reg16, modrm{16}, tmph);

CMPL.RMOD   reg32, modrm 
            *32* tmp1 := reg32 - modrm{32}
            SUBFLAGS32(reg32, modrm{32}, tmp1);

OP1 := { "&", "|", "^" };
LOGB := { "ANDB", "ORB", "XORB" };
LOGW := { "ANDW", "ORW", "XORW" };
LOGL := { "ANDL", "ORL", "XORL" };

LOGB[IDX].IAL i8 
            *8* %al := %al OP1[IDX] i8
            LOGICALFLAGS8(%al);

LOGW[IDX].IAX i16 
            *16* %ax := %ax OP1[IDX] i16
            LOGICALFLAGS16(%ax);

LOGL[IDX].IEAX i32 
            *32* %eax := %eax OP1[IDX] i32
            LOGICALFLAGS32(%eax);

LOGL[IDX].ID modrm, i32 
            *32* modrm := modrm{32} OP1[IDX] i32
            LOGICALFLAGS32(modrm);

LOGW[IDX].IW modrm, i16 
            *16* modrm := modrm{16} OP1[IDX] i16
            LOGICALFLAGS16(modrm);

LOGB[IDX].IB modrm, i8 
            *8* modrm := modrm{8} OP1[IDX] i8
            LOGICALFLAGS8(modrm);

LOGW[IDX].IBOW modrm, i8 
            *16* modrm := modrm OP1[IDX] sgnex(8, 15, i8)
            LOGICALFLAGS16(modrm);

LOGL[IDX].IBOD modrm, i8 
            *32* modrm := modrm OP1[IDX] sgnex(8, 31, i8)
            LOGICALFLAGS32(modrm);

LOGB[IDX].MRB modrm, reg8 
            *8* modrm := modrm{8} OP1[IDX] reg8
            LOGICALFLAGS8(modrm);

LOGW[IDX].MROW modrm, reg16 
            *16* modrm := modrm{16} OP1[IDX] reg16
            LOGICALFLAGS16(modrm);

LOGL[IDX].MROD modrm, reg32 
            *32* modrm := modrm{32} OP1[IDX] reg32
            LOGICALFLAGS32(modrm);

LOGB[IDX].RMB reg8, modrm 
            *8* reg8 := reg8 OP1[IDX] modrm{8}
            LOGICALFLAGS8(reg8);

LOGW[IDX].RMOW reg16, modrm 
            *16* reg16 := reg16 OP1[IDX] modrm{16}
            LOGICALFLAGS16(reg16);

LOGL[IDX].RMOD reg32, modrm 
            *32* reg32 := reg32 OP1[IDX] modrm{32}
            LOGICALFLAGS32(reg32);

OP2 := { "+", "-" };
ARITH_CB := { "ADCB", "SBBB" };
ARITH_CW := { "ADCW", "SBBW" };
ARITH_CL := { "ADCL", "SBBL" };

ARITH_CB[IDX].IAL i8 
            *8* tmpb := %al
            *8* %al := %al OP2[IDX] (i8 + zfill(1,7,%CF));
ADCB.IAL   i8 ADDFLAGS8(tmpb, i8, %al);
SBBB.IAL   i8 SUBFLAGS8(tmpb, i8, %al);

ARITH_CW[IDX].IAX i16 
            *16* tmph := %ax
            *16* %ax := %ax OP2[IDX] (i16 + zfill(1,15,%CF));
ADCW.IAX   i16 ADDFLAGS16(tmph, i16, %ax);
SBBW.IAX   i16 SUBFLAGS16(tmph, i16, %ax);

ARITH_CL[IDX].IEAX i32 
            *32* tmp1 := %eax
            *32* %eax := %eax OP2[IDX] (i32 + zfill(1,31,%CF));
ADCL.IEAX   i32 ADDFLAGS32(tmp1, i32, %eax);
SBBL.IEAX   i32 SUBFLAGS32(tmp1, i32, %eax);

ARITH_CL[IDX].ID reg32, i32 
            *32* tmp1 := reg32
            *32* reg32 := reg32 OP2[IDX] (i32 + zfill(1,31,%CF));
ADCL.ID   reg32, i32 ADDFLAGS32(tmp1, i32, reg32);
SBBL.ID   reg32, i32 SUBFLAGS32(tmp1, i32, reg32);

ARITH_CW[IDX].IW reg16, i16 
            *16* tmph := reg16
            *16* reg16 := reg16 OP2[IDX] (i16 + zfill(1,15,%CF));
ADCW.IW   reg16, i16 ADDFLAGS16(tmph, i16, reg16);
SBBW.IW   reg16, i16 SUBFLAGS16(tmph, i16, reg16);

ARITH_CB[IDX].IB reg8, i8 
            *8* tmpb := reg8
            *8* reg8 := reg8 OP2[IDX] (i8 + zfill(1,7,%CF));
ADCB.IB   reg8, i8 ADDFLAGS8(tmpb, i8, reg8);
SBBB.IB   reg8, i8 SUBFLAGS8(tmpb, i8, reg8);

ARITH_CL[IDX].IBOD reg32, i8 
            *32* tmp1 := reg32
            *32* reg32 := reg32 OP2[IDX] (sgnex(8,31,i8) + zfill(1,31,%CF));
ADCL.IBOD   reg32, i8 ADDFLAGS32(tmp1, sgnex(8,31,i8), reg32);
SBBL.IBOD   reg32, i8 SUBFLAGS32(tmp1, sgnex(8,31,i8), reg32);

ARITH_CB[IDX].MRB modrm, reg8 
            *8* tmpb := modrm
            *8* modrm := tmpb OP2[IDX] (reg8 + zfill(1,7,%CF));
ADCB.MRB   modrm, reg8 ADDFLAGS8(tmpb, reg8, modrm);
SBBB.MRB   modrm, reg8 SUBFLAGS8(tmpb, reg8, modrm);

ARITH_CW[IDX].MROW modrm, reg16 
            *16* tmph := modrm{16}
            *16* modrm := tmph OP2[IDX] (reg16 + zfill(1,15,%CF));
ADCW.MROW   modrm, reg16 ADDFLAGS16(tmph, reg16, modrm{16});
SBBW.MROW   modrm, reg16 SUBFLAGS16(tmph, reg16, modrm{16});

ARITH_CL[IDX].MROD modrm, reg32 
            *32* tmp1 := modrm
            *32* modrm := modrm OP2[IDX] (reg32 + zfill(1,31,%CF));
ADCL.MROD   modrm, reg32 ADDFLAGS32(tmp1, reg32, modrm);
SBBL.MROD   modrm, reg32 SUBFLAGS32(tmp1, reg32, modrm);

ARITH_CB[IDX].RMB reg8, modrm 
            *8* tmpb := reg8
            *8* reg8 := reg8 OP2[IDX] (modrm{8} + zfill(1,7,%CF));
ADCB.RMB   reg8, modrm ADDFLAGS8(tmpb, modrm{8}, reg8);
SBBB.RMB   reg8, modrm SUBFLAGS8(tmpb, modrm{8}, reg8);

ARITH_CW[IDX].RMOW reg16, modrm 
            *16* tmph := reg16
            *16* reg16 := reg16 OP2[IDX] (modrm{16} + zfill(1,15,%CF));
ADCW.RMOW   reg16, modrm ADDFLAGS16(tmph, modrm{16}, reg16);
SBBW.RMOW   reg16, modrm SUBFLAGS16(tmph, modrm{16}, reg16);

ARITH_CL[IDX].RMOD reg32, modrm 
            *32* tmp1 := reg32
            *32* reg32 := reg32 OP2[IDX] (modrm{32} + zfill(1,31,%CF));
ADCL.RMOD   reg32, modrm ADDFLAGS32(tmp1, modrm{32}, reg32);
SBBL.RMOD   reg32, modrm SUBFLAGS32(tmp1, modrm{32}, reg32);


# BSR really sets the target register to the zero-based
# index of the first non-zero bit in source. ZF is set if
# source is 0. 
BSRW	modrm, reg16
			*1* %ZF := nondet(1)
			*16* reg16 := nondet(16);

BSRL	modrm, reg32
			*1* %ZF := nondet(1)
			*32* reg32 := nondet(32);			

BTW.ORW   modrm, reg16 
            *1* %CF := modrm{16}@[reg16:reg16];

BTW.OIW   modrm, i8 
            *1* %CF := modrm{16}@[i8:i8];

BTL.ORD   modrm, reg32 
            *1* %CF := modrm{32}@[reg32:reg32];

BTL.OID   modrm, i8 
            *1* %CF := modrm{32}@[i8:i8];

BTRW.ORW   modrm, reg16 
            *1* %CF := modrm{16}@[reg16:reg16]
            *1* modrm@[reg16:reg16] := 0;

BTRW.OIW   modrm, i8 
            *1* %CF := modrm@[i8:i8]
            *1* modrm@[i8:i8] := 0;

BTRL.ORD   modrm, reg32 
            *1* %CF := modrm@[reg32:reg32]
            *1* modrm@[reg32:reg32] := 0;

BTRL.OID   modrm, i8 
            *1* %CF := modrm@[i8:i8]
            *1* modrm@[i8:i8] := 0;

BTCL.OD   modrm, reg32 
            *32* tmp1 := 1 << reg32
            *1* %CF := modrm@[reg32:reg32]
            *32* modrm := modrm ^ tmp1;

BTSL.OD   modrm, reg32 
            *32* tmp1 := 1 << reg32
            *1* %CF := modrm@[reg32:reg32]
            *32* modrm := modrm | tmp1;

CALLL.JVOW   reloc16
            *32* %esp := %esp - 2
            *16* m[%esp] := %pc@[0:15]
#--JK            *32* %pc := %pc + 3 + reloc16;
            *32* %pc := %pc + reloc16;

#
# --JK : In the Intel Architecture, EIP (%pc) always holds the value of the
# _next_ instruction. So things like 
# *32* %pc := %pc + 5 + reloc32; 
# seem wrong IMHO, especially since m[%esp] := %pc implies that
# the _current_ %pc value is pushed as return value. If this was the
# call's address, it would make no sense... 
#
# Note: the last assignment is not correct. reloc[16 32] is the *host*
# *destination*, not the offset (the offset is not avialable to the SSL, nor
# is the "delta" required to convert from host to native.
# Corrected in the matcher file
CALLL.JVOD   reloc32
            *32* %esp := %esp - 4
            *32* m[%esp] := %pc
#--JK            *32* %pc := %pc + 5 + reloc32;
            *32* %pc := %pc + reloc32;

#
# Do we need this? Does not work currently since seg/off operands are not split by disassembler 
#LCALL   seg, off 
#            *32* %esp := %esp - 4
#            *16* m[%esp] := %cs
#            *16* %cs := seg
#            *32* %esp := %esp - 4
#            *32* m[%esp] := %pc
#            *32* %pc := off;


# Careful: A "call [esp + x]" instruction reads the operand first before modifying esp
#          So, with modrm operands, modify esp last 

CALLL.EVOD   modrm
			*32* tmp1 := modrm 
            *32* %esp := %esp - 4
            *32* m[%esp] := %pc
            *32* %pc := tmp1;

CBTW 		# Intel: CBW    
            *16* %ax := sgnex(8, 15, %al);

CWTL		# Intel: CWDE    
            *32* %eax := sgnex(16,31,%ax);

CWTD		# Intel: CWD    
            *16* %dx := [%ax@[31:31] = 1 ? -1:0];

CLTD		# Intel: CDQ    
            *32* %edx := [%eax@[31:31] = 1 ? -1:0];
            
CLC    
            *1* %CF := 0;

CLD    
            *1* %DF := 0;

CLI    
            *1* %IF := 0;

CMC    
            *1* %CF := ~(%CF);

# Moved ZF assignment forward - otherwise ZF would always be 1 --JK
CMPXCHGB.EV.GB   modrm, reg8 
            *8* tmpb := modrm{8}
            *1* %ZF := [%al = tmpb?1:0]
            *8* modrm := [%al = tmpb?reg8:tmpb]
            *8* %al := tmpb;

CMPXCHGW.EV.GVOW   modrm, reg16 
            *16* tmph := modrm{16}
            *1* %ZF := [%ax = tmph?1:0]
            *16* modrm := [%ax = tmph?reg16:tmph]
            *16* %ax := tmph;

CMPXCHGL.EV.GVOD   modrm, reg32 
            *32* tmp1 := modrm
            *1* %ZF := [%eax = tmp1?1:0]
            *32* modrm := [%eax = tmp1?reg32:tmp1]
            *32* %eax := tmp1;

CPUID
			*32* %eax := nondet(32)
			*32* %ebx := nondet(32)
			*32* %ecx := nondet(32)
			*32* %edx := nondet(32);

# Note that decrement doesn't set the carry flag, so none of the carry related compares, which need SUBFLAGS, should
# ever be needed. If the carry flag IS used, then it will depend on earlier SUBFLAGS, and Boomerang won't handle that
# yet. Use LOGICALFLAGS below to help reduce the problem of etraneous variables caused by reference to the operands of
# the decrement, since these will cause liveness overlaps.
#
# -JK: Jakstab doesn't have this problem, since it expands the flag macros. Changed flag assignments back.
#

OP4 := { "-", "+" };
DEC_INCB := { "DECB", "INCB" };
DEC_INCW := { "DECW", "INCW" };
DEC_INCL := { "DECL", "INCL" };

DEC_INCB[IDX].EB modrm 
            *8* tmpb := modrm{8}
            *8* modrm := modrm{8} OP4[IDX] 1;
DECB.EB   modrm SUBFLAGS8(tmpb, 1, modrm{8});
INCB.EB   modrm ADDFLAGS8(tmpb, 1, modrm{8});
#DEC.EB   modrm LOGICALFLAGS8(modrm{8});
#INC.EB   modrm LOGICALFLAGS8(modrm{8});

DEC_INCW[IDX].EVOW modrm 
            *16* tmph := modrm{16}
            *16* modrm := modrm{16} OP4[IDX] 1;
DECW.EVOW   modrm SUBFLAGS16(tmph, 1, modrm{16});
INCW.EVOW   modrm ADDFLAGS16(tmph, 1, modrm{16});
#DEC.EVOW   modrm LOGICALFLAGS16(modrm{16});
#INC.EVOW   modrm LOGICALFLAGS16(modrm{16});

DEC_INCL[IDX].EVOD modrm 
            *32* tmp1 := modrm
            *32* modrm := modrm OP4[IDX] 1;
DECL.EVOD   modrm SUBFLAGS32(tmp1, 1, modrm);
INCL.EVOD   modrm ADDFLAGS32(tmp1, 1, modrm);
#DEC.EVOD   modrm LOGICALFLAGS32(modrm);
#INC.EVOD   modrm LOGICALFLAGS32(modrm);

DEC_INCW[IDX].OW reg16 
            *16* tmph := reg16
            *16* reg16 := reg16 OP4[IDX] 1;
DECW.OW   reg16 SUBFLAGS16(tmph, 1, reg16);
INCW.OW   reg16 ADDFLAGS16(tmph, 1, reg16);
#DEC.OW   reg16 LOGICALFLAGS16(tmph, 1, reg16);
#INC.OW   reg16 LOGICALFLAGS16(tmph, 1, reg16);

DEC_INCL[IDX].OD reg32 
            *32* tmp1 := reg32
            *32* reg32 := reg32 OP4[IDX] 1;
DECL.OD   reg32 SUBFLAGS32(tmp1, 1, reg32);
INCL.OD   reg32 ADDFLAGS32(tmp1, 1, reg32);
#DEC.OD   reg32 LOGICALFLAGS32(reg32);
#INC.OD   reg32 LOGICALFLAGS32(reg32);

DIVB.AL   modrm 
            *16* tmph := %ax
            *8* %al := tmph / modrm{8}
            *8* %ah := tmph % modrm{8}
            undefineflags( );

DIVW.AX   modrm 
            *32* tmp1 := (zfill(16,31,%dx) << 16) | zfill(16,31,%ax)
            *16* tmph := modrm{16}
            *16* %ax := tmp1 / tmph
            *16* %dx := tmp1 % tmph
            undefineflags( );

DIVL.EAX   modrm 
            *64* tmpl := (zfill(32,63,%edx) << 32) | zfill(32,63,%eax)
            *32* tmp2 := modrm
            *32* %eax := tmpl / tmp2
            *32* %edx := tmpl % tmp2
            undefineflags( );

# --JK This is a simplified version of enter without support
#      for multiple framepointers (we assume i8 == 0)
ENTER   i16, i8 
            *32* %esp := %esp - 4
            *32* m[%esp] := %ebp
			*32* %ebp := %esp
            *32* %esp := %esp - i16;
            
HLT
			halt;

IDIVB   modrm 
            *16* tmph := %ax
            *8* %al := tmph /! modrm{8}
            *8* %ah := tmph %! modrm{8}
            undefineflags( );

IDIVW.AX   modrm 
            *32* tmp1 := (zfill(16,31,%dx) << 16) | zfill(16,31,%ax)
            *16* tmph := modrm{16}
            *16* %ax := tmp1 /! tmph
            *16* %dx := tmp1 %! tmph
            undefineflags( );

IDIVL.EAX   modrm 
            *64* tmpl := (zfill(32,63,%edx) << 32) | zfill(32,63,%eax)
            *32* tmp2 := modrm
            *32* %eax := tmpl /! tmp2
            *32* %edx := tmpl %! tmp2
            undefineflags( );
            
MULB.AL   modrm 
            *16* %ax := %al *! modrm{8}
            MULTFLAGS8(%ax);

MULW.AX   modrm 
            *32* tmp2 := %ax * modrm{16}
            *16* %ax := tmp2@[0:15]
            *16* %dx := tmp2@[16:31]
            MULTFLAGS16(tmp2);

MULL.EAX   modrm 
            *64* tmpl := %eax * modrm{32}
            *32* %eax := tmpl@[0:31]
            *32* %edx := tmpl@[32:63]
            MULTFLAGS32(tmpl);

IMULB.AL   modrm 
            *16* %ax := %al *! modrm{8}
            IMULTFLAGS8(%ax);

IMULW.AX   modrm 
            *32* tmp2 := %ax *! modrm
            *16* %ax := tmp2@[0:15]
            *16* %dx := tmp2@[16:31]
            IMULTFLAGS16(tmp2);

IMULL.EAX   modrm 
            *64* tmpl := %eax *! modrm
            *32* %eax := tmpl@[0:31]
            *32* %edx := tmpl@[32:63]
            IMULTFLAGS32(tmpl);

IMULW.RMOW   reg16, modrm
            *32* tmp1 := modrm{16} *! reg16
            *16* reg16 := tmp1@[0:15]
            IMULTFLAGS16(tmp1);

IMULL.RMOD   reg32, modrm
			*64* tmpl := modrm{32} *! reg32
            *32* reg32 := tmpl@[0:31]
            IMULTFLAGS32(tmpl);

IMULW.IVOW   reg16, modrm, i16 
            *32* tmp1 := modrm{16} *! i16
            *16* reg16 := tmp1@[0:15]
            IMULTFLAGS16(tmp1);

IMULL.IVOD   reg32, modrm, i32 
            *64* tmpl := modrm{32} *! i32
            *32* reg32 := tmpl@[0:31]
            IMULTFLAGS32(tmpl);

IMULW.IBOW   reg16, modrm, i8 
            *32* tmp1 := modrm{8} *! sgnex(8,15,i8)
            *16* reg16 := tmp1@[0:15]
            IMULTFLAGS16(tmp1);

IMULL.IBOD   reg32, modrm, i8 
            *64* tmpl := modrm{32} *! sgnex(8,31,i8)
            *32* reg32 := tmpl@[0:31]
            IMULTFLAGS32(tmpl);

INB.AL
			*8* %al := nondet(8);

INW.AX
			*16* %ax := nondet(16);

INL.EAX
			*32* %eax := nondet(32);

INB.IAL i8
			*8* %al := nondet(8);

INW.IAX i8
			*16* %ax := nondet(16);

INL.IEAX i8
			*32* %eax := nondet(32);

OUTB
			_;

OUTW
			_;

OUTL
			_;

INT3
			halt;			# Not expected to be seen in correct code, but decode anyway

# Condition codes for conditional jumps
#CONDJ := { "~%CF & ~%ZF"        , "~%CF & ~%ZF"        , "~%CF"             , "~%CF"             , 
CONDJ := { "~(%CF | %ZF)"        , "~(%CF | ~%ZF)"        , "~%CF"             , "~%CF"             , 
           "%CF"                , "%CF"                , "%CF | %ZF"        , "%CF | %ZF"        , 
           "%CF"                , "%cx = 0"            , "%ZF"              , "%ZF"              , 
           "(%SF = %OF) & ~%ZF", "(%SF = %OF) & ~%ZF"  , "%SF = %OF"        , "%SF = %OF"        , 
           "%SF ^ %OF"          , "%SF ^ %OF"          , "(%SF ^ %OF) | %ZF", "(%SF ^ %ZF) | %ZF", 
           "~%CF"               , "~%ZF"               , "~%ZF"             , "~%OF"             ,
           "~%PF"               , "~%PF"               , "~%SF"             , "%OF"              , 
           "%PF"                , "%PF"                , "%SF"              , "%ecx = 0" };

JCCS := { "JA"  , "JNBE", "JAE" , "JNB" , 
          "JB"  , "JNAE", "JBE" , "JNA" , 
          "JC"  , "JCXZ", "JE"  , "JZ"  , 
          "JG"  , "JNLE", "JGE" , "JNL" , 
          "JL"  , "JNGE", "JLE" , "JNG" , 
          "JNC" , "JNE" , "JNZ" , "JNO" , 
          "JNP" , "JPO" , "JNS" , "JO"  ,
          "JP"  , "JPE" , "JS"  , "JECXZ" };

#   Condition meaning related to last flag manipulating instruction         
#MCONDJ := { "x >u y "      , "x >u y"        , "x >=u y"    , "x >=u y"    , 
#           "x <u y"       , "x <u y"        , "x <=u y"    , "x <=u y"    , 
#           "x <u y"       , "%cx = 0"       , "x = y"      , "x = y"      , 
#           "x > y"        , "x > y"         , "x >= y"     , "x >= y"     , 
#           "x < y"        , "x < y"         , "x <= y"     , "x <= y"     , 
#           "x >=u y"      , "x ~= y"        , "x ~= y"     , "~%OF"       ,
#           "~%PF"         , "~%PF"          , "~%SF"       , "%OF"        , 
#           "%PF"          , "%PF"           , "%SF"        , "%ecx = 0" };
          
JSZW := { ".JVOW" };
JSZD := { ".JVOD" };
JSZB := { ".JB" };

JMP32S := JCCS JSZW;
JMP16S := JCCS JSZD;
JMP8S := JCCS JSZB;
             

JMP32S[IDX]   reloc32
            *32* %pc := [(CONDJ[IDX] = 1)?%pc + reloc32:%pc]; 
#--JK            *32* %pc := [(CONDJ[IDX] = 1)?%pc + 6 + reloc32:%pc];

JMP16S[IDX]   reloc16 
            *32* %pc := [(CONDJ[IDX] = 1)?%pc + reloc16:%pc];
#--JK            *32* %pc := [(CONDJ[IDX] = 1)?%pc + 4 + reloc16:%pc];

JMP8S[IDX]   reloc8 
            *32* %pc := [(CONDJ[IDX] = 1)?%pc + reloc8:%pc];
#--JK            *32* %pc := [(CONDJ[IDX] = 1)?%pc + 2 + reloc8:%pc];



JMP.JB   reloc8
            *32* %pc := %pc + reloc8; 
#--JK            *32* %pc := %pc + 2 + reloc8;

JMP.JVOW   reloc16
            *32* %pc := %pc + reloc16; 
#--JK            *32* %pc := %pc + 3 + reloc16;

JMPL.JVOD   reloc32
            *32* %pc := %pc + reloc32; 
#--JK            *32* %pc := %pc + 5 + reloc32;

JMPL.EVOD   modrm
            *32* %pc := modrm;
            
#LJMP	seg, off
#            *16* %cs := seg
#            *32* %pc := off;

LAHF
			*8*  %ah := zfill(1,7,%CF) | (zfill(1,7,%ZF) << 6) | (zfill(1,7,%SF) << 7);

LEAL.OD   reg32, mem 
            *32* reg32 := addr(mem);

LEAW.OW   reg16, mem 
            *16* reg16 := addr(mem);

LEAVE    
            *32* %esp := %ebp
            *32* %ebp := m[%esp]{32}
            *32* %esp := %esp + 4;

COND4 := { "%ecx ~= 0", "%ecx ~= 0 & %ZF", "%ecx ~= 0 & %ZF",
           "%ecx ~= 0 & ~%ZF", "%ecx ~= 0 & ~%ZF" };
LOOPS := { "LOOP", "LOOPE", "LOOPZ", "LOOPNE", "LOOPNZ" };

LOOPS[IDX]   reloc8 
            *32* %ecx := %ecx - 1
            *32* %pc := [COND4[IDX]?%pc + reloc8:%pc];

MOVB.EB.IB   modrm, i8 
            *8* modrm := i8;

MOVW.EW.IVOW   modrm, i16 
            *16* modrm := i16;

MOVL.ED.IVOD   modrm, i32
            *32* modrm := i32;

MOVB.IB   reg8, i8 
            *8* reg8 := i8;

MOVW.IW   reg16, i16 
            *16* reg16 := i16;

MOVL.ID   reg32, i32 
            *32* reg32 := i32;

MOVB.MRB   modrm, reg8 
            *8* modrm := reg8;

MOVW.MROW   modrm, reg16 
            *16* modrm := reg16;

MOVL.MROD   modrm, reg32 
            *32* modrm := reg32;

MOVB.RMB   reg8, modrm 
            *8* reg8 := modrm{8};

MOVW.RMOW   reg16, modrm 
            *16* reg16 := modrm{16};

MOVL.RMOD   reg32, modrm 
            *32* reg32 := modrm{32};

MOVSBW.GV.EBOW reg16, modrm		# Intel: MOVSX 
            *16* reg16 := sgnex(8, 15, modrm{8});

MOVSBL.GV.EBOD   reg32, modrm	# Intel: MOVSX 
            *32* reg32 := sgnex(8, 31, modrm{8});

MOVSWL.GV.EW   reg32, modrm		# Intel: MOVSX 
            *32* reg32 := sgnex(16, 31, modrm{16});

MOVZBW.GV.EBOW   reg16, modrm	# Intel: MOVZX 
            *16* reg16 := zfill(8, 15, modrm{8});

MOVZBL.GV.EBOD   reg32, modrm	# Intel: MOVZX 
            *32* reg32 := zfill(8, 31, modrm{8});

MOVZWL.GV.EW   reg32, modrm		# Intel: MOVZX 
            *32* reg32 := zfill(16, 31, modrm{16});

NEGB	modrm 
            *8* tmpb := modrm{8}
            *8* modrm := 0 - modrm{8}
            SUBFLAGS8(0, tmpb, modrm{8});

NEGW	modrm 
            *16* tmph := modrm{16}
            *16* modrm := 0 - modrm{16}
            SUBFLAGS16(0, tmph, modrm);

NEGL	modrm 
            *32* tmp1 := modrm{32}
            *32* modrm := 0 - modrm{32}
            SUBFLAGS32(0, tmp1, modrm);

NOP    
            _ ;

NOTB.B   modrm 
            *8* modrm := ~modrm{8};

NOTW.OW   modrm 
            *16* modrm := ~modrm{16};

NOTL.OD   modrm 
            *32* modrm := ~modrm{32};

POPW.EVOW   modrm 
            *16* modrm := m[%esp]{16}
            *32* %esp := %esp + 2;

POPL.EVOD   modrm 
            *32* modrm := m[%esp]{32}
            *32* %esp := %esp + 4;

POPW.OW   reg16 
            *16* reg16 := m[%esp]{16}
            *32* %esp := %esp + 2;

POPL.OD   reg32 
            *32* reg32 := m[%esp]{32}
            *32* %esp := %esp + 4;

POPL.DS
            *16* %ds := m[%esp]{16}
            *32* %esp := %esp + 4;

POPL.ES 
            *16* %es := m[%esp]{16}
            *32* %esp := %esp + 4;

POPL.FS 
            *16* %fs := m[%esp]{16}
            *32* %esp := %esp + 4;

POPL.GS 
            *16* %gs := m[%esp]{16}
            *32* %esp := %esp + 4;

POPL.SS 
            *16* %ss := m[%esp]{16}
            *32* %esp := %esp + 4;

#POPA
#            *16* %di := m[%esp]{16}
#            *16* %si := m[%esp + 2]{16}
#            *16* %bp := m[%esp + 4]{16}
#            # %sp slot is skipped
#            *16* %bx := m[%esp + 8]{16}
#            *16* %dx := m[%esp + 10]{16}
#            *16* %cx := m[%esp + 12]{16}
#            *16* %ax := m[%esp + 14]{16}
#            *32* %esp := %esp + 16;

# Called POPAD in Intel manual
POPA
            *32* %edi := m[%esp]{32}
            *32* %esi := m[%esp + 4]{32}
            *32* %ebp := m[%esp + 8]{32}
            # %esp slot is skipped
            *32* %ebx := m[%esp + 16]{32}
            *32* %edx := m[%esp + 20]{32}
            *32* %ecx := m[%esp + 24]{32}
            *32* %eax := m[%esp + 28]{32}
            *32* %esp := %esp + 32;

#PUSHA
#            *16* m[%esp - 2] := %ax
#            *16* m[%esp - 4] := %cx
#            *16* m[%esp - 6] := %dx
#            *16* m[%esp - 8] := %bx
#            *16* m[%esp - 10] := %sp # value at instruction start
#            *16* m[%esp - 12] := %bp
#            *16* m[%esp - 14] := %si
#            *16* m[%esp - 16] := %di
#            *32* %esp := %esp - 16;
            
# Called PUSHAD in Intel manual
PUSHA
            *32* m[%esp - 4] := %eax
            *32* m[%esp - 8] := %ecx
            *32* m[%esp - 12] := %edx
            *32* m[%esp - 16] := %ebx
            *32* m[%esp - 20] := %esp # value at instruction start
            *32* m[%esp - 24] := %ebp
            *32* m[%esp - 28] := %esi
            *32* m[%esp - 32] := %edi
            *32* %esp := %esp - 32;

# PUSHs
# Careful: A "push [esp + x]" instruction reads the operand first before modifying esp
#          So, with modrm operands, modify esp last 

PUSHW.EVOW   modrm 
            *16* m[%esp - 2] := modrm{16}
            *32* %esp := %esp - 2;

PUSHL.EVOD   modrm 
            *32* m[%esp - 4] := modrm{32}
            *32* %esp := %esp - 4;

PUSHL.IXOB   i8 
            *32* %esp := %esp - 4
            *32* m[%esp] := sgnex(8, 31, i8);

# Note: 66 6A nn: 8 bit immediate operand (nn), but 16 bit push!
PUSHW.IXOW   i8
            *32* %esp := %esp - 2
            *16* m[%esp] := sgnex(8, 15, i8);

PUSHW.IVOW   i16 
            *32* %esp := %esp - 2
            *16* m[%esp] := i16;

PUSHL.IVOD   i32 
            *32* %esp := %esp - 4
            *32* m[%esp] := i32;

PUSHW.OW   reg16 
            *32* %esp := %esp - 2
            *16* m[%esp] := reg16;

PUSHL.OD   reg32 
            *32* %esp := %esp - 4
            *32* m[%esp] := reg32;

PUSHL.CS
            *32* %esp := %esp - 4
            *16* m[%esp] := %cs;
	    
PUSHL.DS
            *32* %esp := %esp - 4
            *16* m[%esp] := %ds;

PUSHL.ES
            *32* %esp := %esp - 4
            *16* m[%esp] := %es;
            
PUSHL.FS
            *32* %esp := %esp - 4
            *16* m[%esp] := %fs;
            
PUSHL.GS
            *32* %esp := %esp - 4
            *16* m[%esp] := %gs;
            
PUSHL.SS
            *32* %esp := %esp - 4
            *16* m[%esp] := %ss;
            
PUSHFW
			*32* %esp := %esp - 2
			*16* m[%esp] := (zfill(1,15,%OF)<<11) | (zfill(1,15,%DF)<<10) | (zfill(1,15,%IF)<<9) | (zfill(1,15,%SF)<<7) | (zfill(1,15,%ZF)<<6) | (zfill(1,15,%AF)<<4) | (zfill(1,15,%PF)<<2) | zfill(1,15,%CF) ;

PUSHFL
			*32* %esp := %esp - 4
			*32* m[%esp] := (zfill(1,31,%OF)<<11) | (zfill(1,31,%DF)<<10) | (zfill(1,31,%IF)<<9) | (zfill(1,31,%SF)<<7) | (zfill(1,31,%ZF)<<6) | (zfill(1,31,%AF)<<4) | (zfill(1,31,%PF)<<2) | zfill(1,31,%CF) ;

POPFW
			*1* %CF := m[%esp]{16}@[0:0] 
			*1* %PF := m[%esp]{16}@[2:2] 
			*1* %AF := m[%esp]{16}@[4:4] 
			*1* %ZF := m[%esp]{16}@[6:6] 
			*1* %SF := m[%esp]{16}@[7:7] 
			*1* %IF := m[%esp]{16}@[9:9] 
#			*1* %DF := m[%esp]{16}@[10:10]
# Hack!
			*1* %DF := 1 
			*1* %OF := m[%esp]{16}@[11:11] 
			*32* %esp := %esp + 2;

POPFL
			*1* %CF := m[%esp]{32}@[0:0] 
			*1* %PF := m[%esp]{32}@[2:2] 
			*1* %AF := m[%esp]{32}@[4:4] 
			*1* %ZF := m[%esp]{32}@[6:6] 
			*1* %SF := m[%esp]{32}@[7:7] 
			*1* %IF := m[%esp]{32}@[9:9] 
			*1* %DF := m[%esp]{32}@[10:10] 
			*1* %OF := m[%esp]{32}@[11:11] 
			*32* %esp := %esp + 4;

RDTSC
            *64* tmpl := tickcount(64)
            *32* %eax := tmpl@[0:31]
            *32* %edx := tmpl@[32:63];

OP4 := { "rlc", "rrc", "rl", "rr" };
ROTB := { "RCLB", "RCRB", "ROLB", "RORB" };
ROTW := { "RCLW", "RCRW", "ROLW", "RORW" };
ROTL := { "RCLL", "RCRL", "ROLL", "RORL" };

ROLSB := { "RCLB","ROLB" };
ROLSW := { "RCLW","ROLW" };
ROLSL := { "RCLL","ROLL" };
RORSB := { "RCRB","RORB" };
RORSW := { "RCRW","RORW" };
RORSL := { "RCRL","RORL" };

ROTB[IDX].B.EV.1 modrm 
            *8* tmpb1 := modrm{8}
            *8* tmpb2 := tmpb OP4[IDX] 1
            *8* modrm := tmpb2;
ROLSB[IDX].B.EV.1 modrm   ROLFLAGS8(tmpb2, tmpb1, 1);
RORSB[IDX].B.EV.1 modrm   RORFLAGS8(tmpb2, tmpb1, 1);

ROTW[IDX].B.EV.1OW modrm 
            *16* tmph1 := modrm{16}
            *16* tmph2 := tmph1 OP4[IDX] 1
            *16* modrm := tmph2;
ROLSW[IDX].B.EV.1OW modrm   ROLFLAGS16(tmph2, tmph1, 1);
RORSW[IDX].B.EV.1OW modrm   RORFLAGS16(tmph2, tmph1, 1);

ROTL[IDX].B.EV.1OD modrm 
            *32* tmp1 := modrm{32}
            *32* tmp2 := tmp1 OP4[IDX] 1
            *32* modrm := tmp2;
ROLSL[IDX].B.EV.1OD modrm   ROLFLAGS32(tmp2, tmp1, 1);
RORSL[IDX].B.EV.1OD modrm   RORFLAGS32(tmp2, tmp1, 1);

ROTB[IDX].B.EV.CL modrm 
            *8* tmpb1 := modrm{8}
            *8* tmpb2 := tmpb1 OP4[IDX] %ecx
            *8* modrm := tmpb2;
ROLSB[IDX].B.EV.CL   modrm  ROLFLAGS8(tmpb2, tmpb1, %ecx);
RORSB[IDX].B.EV.CL   modrm  RORFLAGS8(tmpb2, tmpb1, %ecx);

ROTW[IDX].B.EV.CLOW modrm 
            *16* tmph1 := modrm{16}
            *16* tmph2 := tmph1 OP4[IDX] %ecx
            *16* modrm := tmph2;
ROLSW[IDX].B.EV.CLOW   modrm  ROLFLAGS16(tmph2, tmph1, %ecx);
RORSW[IDX].B.EV.CLOW   modrm  RORFLAGS16(tmph2, tmph1, %ecx);

ROTL[IDX].B.EV.CLOD modrm 
            *32* tmp1 := modrm{32}
            *32* tmp2 := tmp1 OP4[IDX] %ecx
            *32* modrm := tmp2;
ROLSL[IDX].B.EV.CLOD   modrm  ROLFLAGS32(tmp2, tmp1, %ecx);
RORSL[IDX].B.EV.CLOD   modrm  RORFLAGS32(tmp2, tmp1, %ecx);

ROTB[IDX].B.EB.IB modrm, i8 
            *8* tmpb1 := modrm{8}
            *8* tmpb2 := tmpb1 OP4[IDX] i8
            *8* modrm := tmpb2;
ROLSB[IDX].B.EB.IB   modrm, i8  ROLFLAGS8(tmpb2, tmpb1, i8);
RORSB[IDX].B.EB.IB   modrm, i8  RORFLAGS8(tmpb2, tmpb1, i8);

ROTW[IDX].B.EV.IBOW modrm, i8 
            *16* tmph1 := modrm{16}
            *16* tmph2 := tmph1 OP4[IDX] sgnex(8, 15, i8)
            *16* modrm := tmph2;
ROLSW[IDX].B.EV.IBOW   modrm, i8  
            ROLFLAGS16(tmph2, tmph1, i8);
RORSW[IDX].B.EV.IBOW   modrm, i8  
            RORFLAGS16(tmph2, tmph1, i8);

ROTL[IDX].B.EV.IBOD modrm, i8 
            *32* tmp1 := modrm{8}
            *32* tmp2 := tmp1 OP4[IDX] i8
            *32* modrm := tmp2;
ROLSL[IDX].B.EV.IBOD   modrm, i8  ROLFLAGS32(tmp2, tmp1, i8);
RORSL[IDX].B.EV.IBOD   modrm, i8  RORFLAGS32(tmp2, tmp1, i8);

RETL
            *32* retaddr := m[%esp]{32}
            *32* %esp := %esp + 4
            *32* %pc := retaddr;
#			*32* %pc := m[%esp - 4]{32};
# -JK changed all pc assignments to occur last.
#     we now use tmp1 to allow forgetting the stack below esp


RETL.IW   i16
			*32* retaddr := m[%esp]{32}
            *32* %esp := %esp + 4 + zfill(16,31,i16)
            *32* %pc := retaddr;
#			*32* %pc := m[%esp - 4 - i16]{32};

LRET
            *32* retaddr := m[%esp]{32}
            *16* %cs := m[%esp + 4]{16}
            *32* %esp := %esp + 8
            *32* %pc := retaddr;

LRET.IW   i16
            *32* retaddr := m[%esp]{32}
            *16* %cs := m[%esp + 4]{16}
            *32* %esp := %esp + 8 + zfill(16,31,i16)
            *32* %pc := retaddr;

SAHF    
            *1* %SF := %ah@[7:7]
            *1* %ZF := %ah@[6:6]
            *1* %PF := %ah@[2:2]
            *1* %CF := %ah@[0:0];

# Conditions are similar to the Jcc conditions, only CXZ is missing
CONDS := { "~%CF & ~%ZF"        , "~%CF & ~%ZF"        , "~%CF"             , "~%CF"             , 
           "%CF"                , "%CF"                , "%CF | %ZF"        , "%CF | %ZF"        , 
           "%CF"                ,                        "%ZF"              , "%ZF"              , 
           "~(%SF ^ %OF) & ~%ZF", "~(%SF ^ %OF) & ~%ZF", "~(%SF ^ %OF)"     , "~(%SF ^ %OF)"     , 
           "%SF ^ %OF"          , "%SF ^ %OF"          , "(%SF ^ %OF) | %ZF", "(%SF ^ %ZF) | %ZF", 
           "~%CF"               , "~%ZF"               , "~%ZF"             , "~%OF"             ,
           "~%PF"               , "~%PF"               , "~%SF"             , "%OF"              , 
           "%PF"                , "%PF"                , "%SF" };

SETCCS := { "SETA"  , "SETNBE", "SETAE" , "SETNB" , 
            "SETB"  , "SETNAE", "SETBE" , "SETNA" , 
            "SETC"  ,           "SETE"  , "SETZ"  , 
            "SETG"  , "SETNLE", "SETGE" , "SETNL" , 
            "SETL"  , "SETNGE", "SETLE" , "SETNG" , 
            "SETNC" , "SETNE" , "SETNZ" , "SETNO" , 
            "SETNP" , "SETPO" , "SETNS" , "SETO"  ,
            "SETP"  , "SETPE" , "SETS" };
            
SETCCS[IDX]^"B" modrm
            *8* modrm := [ CONDS[IDX] = 1 ?1:0];
            
CMOVCCS := { "CMOVA"  , "CMOVNBE", "CMOVAE" , "CMOVNB" , 
            "CMOVB"  , "CMOVNAE", "CMOVBE" , "CMOVNA" , 
            "CMOVC"  ,           "CMOVE"  , "CMOVZ"  , 
            "CMOVG"  , "CMOVNLE", "CMOVGE" , "CMOVNL" , 
            "CMOVL"  , "CMOVNGE", "CMOVLE" , "CMOVNG" , 
            "CMOVNC" , "CMOVNE" , "CMOVNZ" , "CMOVNO" , 
            "CMOVNP" , "CMOVPO" , "CMOVNS" , "CMOVO"  ,
            "CMOVP"  , "CMOVPE" , "CMOVS" };

CMOVCCS[IDX]"W" reg16, modrm
            *16* reg16 := [ CONDS[IDX] = 1?modrm{16}:reg16];

CMOVCCS[IDX]"L" reg32, modrm
            *32* reg32 := [ CONDS[IDX] = 1 ? modrm{32}:reg32];

OP5 := { "<<", ">>A", ">>" };
SHTB := { "SHLB", "SARB", "SHRB" };
SHTW := { "SHLW", "SARW", "SHRW" };
SHTL := { "SHLL", "SARL", "SHRL" };

SHTB[IDX].B.EB.1 modrm 
            *8* tmpb := modrm{8}
            *8* modrm := modrm{8} OP5[IDX] 1;
SHLB.B.EB.1   modrm  SALFLAGS8(modrm{8}, tmpb, 1);
SARB.B.EB.1   modrm  SARFLAGS(modrm{8}, tmpb, 1);
SHRB.B.EB.1   modrm  SHRFLAGS8(modrm{8}, tmpb, 1);

SHTW[IDX].B.EV.1OW modrm 
            *16* tmph := modrm{16}
            *16* modrm := modrm{16} OP5[IDX] 1;
SHLW.B.EV.1OW   modrm  SALFLAGS16(modrm{16}, modrm{16}, 1);
SARW.B.EV.1OW   modrm  SARFLAGS(modrm{16}, tmph, 1);
SHRW.B.EV.1OW   modrm  SHRFLAGS16(modrm{16}, tmph, 1);

SHTL[IDX].B.EV.1OD modrm 
            *32* tmp1 := modrm{32}
            *32* modrm := modrm{32} OP5[IDX] 1;
SHLL.B.EV.1OD   modrm  SALFLAGS32(modrm, tmp1, 1);
SARL.B.EV.1OD   modrm  SARFLAGS(modrm, tmp1, 1);
SHRL.B.EV.1OD   modrm  SHRFLAGS32(modrm, tmp1, 1);

SHTB[IDX].B.EB.CL modrm 
            *8* tmpb := modrm{8}
            *8* modrm := modrm{8} OP5[IDX] %ecx;
SHLB.B.EB.CL   modrm  SALFLAGS8(modrm{8}, tmpb, %ecx);
SARB.B.EB.CL   modrm  SARFLAGS(modrm{8}, tmpb, %ecx);
SHRB.B.EB.CL   modrm  SHRFLAGS8(modrm{8}, tmpb, %ecx);

SHTW[IDX].B.EV.CLOW modrm 
            *16* tmph := modrm{16}
            *16* modrm := modrm{16} OP5[IDX] %ecx;
SHLW.B.EV.CLOW   modrm   SALFLAGS16(modrm{16}, tmph, %ecx);
SARW.B.EV.CLOW   modrm   SARFLAGS(modrm{16}, tmph, %ecx);
SHRW.B.EV.CLOW   modrm   SHRFLAGS16(modrm{16}, tmph, %ecx);

SHTL[IDX].B.EV.CLOD modrm 
            *32* tmp1 := modrm{32}
            *32* modrm := modrm{32} OP5[IDX] %ecx;
SHLL.B.EV.CLOD   modrm   SALFLAGS32(modrm, tmp1, %ecx);
SARL.B.EV.CLOD   modrm   SARFLAGS(modrm, tmp1, %ecx);
SHRL.B.EV.CLOD   modrm   SHRFLAGS32(modrm, tmp1, %ecx);

SHTB[IDX].B.EB.IB modrm, i8 
            *8* tmpb := modrm{8}
            *8* modrm := modrm{8} OP5[IDX] i8;
SHLB.B.EB.IB   modrm, i8   SALFLAGS8(modrm{8}, tmpb, i8);
SARB.B.EB.IB   modrm, i8   SARFLAGS(modrm{8}, tmpb, i8);
SHRB.B.EB.IB   modrm, i8   SHRFLAGS8(modrm{8}, tmpb, i8);

SHTW[IDX].B.EV.IBOW modrm, i8 
            *16* tmph := modrm{16}
            *16* modrm := modrm{16} OP5[IDX] i8;
SHLW.B.EV.IBOW   modrm, i8   SALFLAGS16(modrm{16}, tmph, i8);
SARW.B.EV.IBOW   modrm, i8   SARFLAGS(modrm{16}, tmph, i8);
SHRW.B.EV.IBOW   modrm, i8   SHRFLAGS16(modrm{16}, tmph, i8);

SHTL[IDX].B.EV.IBOD modrm, i8 
            *32* tmp1 := modrm{32}
            *32* modrm := modrm{32} OP5[IDX] i8;
SHLL.B.EV.IBOD   modrm, i8   SALFLAGS32(modrm, tmp1, i8);
SARL.B.EV.IBOD   modrm, i8   SARFLAGS(modrm, tmp1, i8);
SHRL.B.EV.IBOD   modrm, i8   SHRFLAGS32(modrm, tmp1, i8);

OP6 := { "<<", ">>" };
SHTDW := { "SHLDW", "SHRDW" };
SHTDL := { "SHLDL", "SHRDL" };

SHTDW[IDX].CLOW modrm, reg16 
            *8*  tmpb := zfill(5,7,%cl@[0:4])
            *32* tmp2 := zfill(16,31,reg16) << 16
            *32* tmp3 := tmp2 + zfill(16,31,modrm{16})
            *32* tmp5 := tmp3 OP6[IDX] tmpb
            *16* modrm := tmp5@[0:15];
SHLDW.CLOW   modrm, reg16  SHLDFLAGS32(tmp5, tmp3, tmpb);
SHRDW.CLOW   modrm, reg16  SHRDFLAGS32(tmp5, tmp3, tmpb);

SHTDL[IDX].CLOD modrm, reg32 
            *8*  tmpb := zfill(5,7,%cl@[0:4])
            *64* tmpq2 := zfill(32,63,reg32) << 32
            *64* tmpq3 := tmpq2 + zfill(32,63,modrm{32})
            *64* tmpq5 := tmpq3 OP6[IDX] tmpb
            *32* modrm := tmpq5@[0:31];
SHLDL.CLOD   modrm, reg32  SHLDFLAGS64(tmpq5, tmpq3, tmpb);
SHRDL.CLOD   modrm, reg32  SHRDFLAGS64(tmpq5, tmpq3, tmpb);

SHTDW[IDX].IBOW modrm, reg16, i8 
            *8*  tmpb := zfill(5,7,i8@[0:4])
            *32* tmp2 := zfill(16,31,reg16) << 16
            *32* tmp3 := tmp2 + zfill(16,31,modrm{16})
            *32* tmp5 := tmp3 OP6[IDX] tmpb
            *16* modrm := tmp5@[0:15];
SHLDW.IBOW   modrm, reg16, i8   SHLDFLAGS32(tmp5, tmp3, tmpb);
SHRDW.IBOW   modrm, reg16, i8   SHRDFLAGS32(tmp5, tmp3, tmpb);


SHTDL[IDX].IBOD modrm, reg32, i8 
            *8*  tmpb := zfill(5,7,i8@[0:4])
            *64* tmpq2 := zfill(32,63,reg32) << 32
            *64* tmpq3 := tmpq2 + zfill(32,63,modrm{32})
            *64* tmpq5 := tmpq3 OP6[IDX] tmpb
            *32* modrm := tmpq5@[0:31];
SHLDL.IBOD   modrm, reg32, i8  SHLDFLAGS64(tmpq5, tmpq3, tmpb);
SHRDL.IBOD   modrm, reg32, i8  SHRDFLAGS64(tmpq5, tmpq3, tmpb);

STC    *1* %CF := 1;

STD    *1* %DF := 1;

STI    *1* %IF := 1;


# FIXME: Summaries currently ignore %DF

REPSTOSB.SUMMARY
		MEMSET %edi, %al, %ecx
		*32* %edi := %edi + %ecx
		*32* %ecx := 0;

REPSTOSW.SUMMARY
		MEMSET %edi, %ax, %ecx
		*32* %edi := %edi + (%ecx << 1)
		*32* %ecx := 0;

REPSTOSL.SUMMARY
		MEMSET %edi, %eax, %ecx
		*32* %edi := %edi + (%ecx << 2)
		*32* %ecx := 0;

REPMOVSB.SUMMARY
		MEMCPY %esi, %edi, %ecx
		*32* %esi := %esi + %ecx
		*32* %edi := %edi + %ecx
		*32* %ecx := 0;

REPMOVSW.SUMMARY
		MEMCPY %esi, %edi, (%ecx << 1)
		*32* %esi := %esi + (%ecx << 1)
		*32* %edi := %edi + (%ecx << 1)
		*32* %ecx := 0;

REPMOVSL.SUMMARY
		MEMCPY %esi, %edi, (%ecx << 2)
		*32* %esi := %esi + (%ecx << 2)
		*32* %edi := %edi + (%ecx << 2)
		*32* %ecx := 0;

# The string instructions
REPS := {"REP", "REPNE"};                   # Repeat prefixes
OREPS := { REPS, ""};                       # Optional repeat prefixes

# String instructions, not repeated
STRS := { "CMPSB", "CMPSW", "CMPSL", "SCASB", "SCASW", "SCASL", 
          "LODSB", "LODSW", "LODSL", "MOVSB", "MOVSW", "MOVSL", "STOSB", "STOSW", "STOSL", 
          "INSB", "INSW", "INSL", "OUTSB", "OUTSW", "OUTSL" };

# String instructions, repeated
STRS_R := REPS STRS;

STRFL :=       { "CMPSB", "CMPSW", "CMPSL", "SCASB", "SCASW", "SCASL" };                   # Update flags
STRFLB :=       { "CMPSB", "SCASB" };
STRFLW :=       { "CMPSW", "SCASW" };
STRFLL :=       { "CMPSL", "SCASL" };
STRNF :=       { "LODSB", "LODSW", "LODSL", "MOVSB", "MOVSW", "MOVSL", "STOSB", "STOSW", "STOSL", 
                 "INSB", "INSW", "INSL", "OUTSB", "OUTSW", "OUTSL" };           # No update flags
STRSIB := OREPS { "CMPSB", "LODSB", "MOVSB", "OUTSB"};          # Update esi
STRSIW := OREPS { "CMPSW", "LODSW", "MOVSW", "OUTSW"};          # Update esi
STRSIL := OREPS { "CMPSL", "LODSL", "MOVSL", "OUTSL"};          # Update esi
STRDIB := OREPS { "CMPSB", "MOVSB", "SCASB", "STOSB", "INSB"};  # Update edi
STRDIW := OREPS { "CMPSW", "MOVSW", "SCASW", "STOSW", "INSW" };  # Update edi
STRDIL := OREPS { "CMPSL", "MOVSL", "SCASL", "STOSL", "INSL" };  # Update edi
STRFLB_OR := OREPS STRFLB;                            # Optionally repeated; flags
STRFLW_OR := OREPS STRFLW;                            # Optionally repeated; flags
STRFLL_OR := OREPS STRFLL;                            # Optionally repeated; flags

CMPSB_OR := OREPS CMPSB;      # Compare with optional repeat
CMPSW_OR := OREPS CMPSW;      # Compare with optional repeat
CMPSL_OR := OREPS CMPSL;      # Compare with optional repeat
LODSB_OR := OREPS LODSB;      # Load with optional repeat
LODSW_OR := OREPS LODSW;      # Load with optional repeat
LODSL_OR := OREPS LODSL;      # Load with optional repeat
MOVSB_OR := OREPS MOVSB;      # Move with optional repeat
MOVSW_OR := OREPS MOVSW;      # Move with optional repeat
MOVSL_OR := OREPS MOVSL;      # Move with optional repeat
SCASB_OR := OREPS SCASB;      # Scan with optional repeat
SCASW_OR := OREPS SCASW;      # Scan with optional repeat
SCASL_OR := OREPS SCASL;      # Scan with optional repeat
STOSB_OR := OREPS STOSB;      # Store with optional repeat
STOSW_OR := OREPS STOSW;      # Store with optional repeat
STOSL_OR := OREPS STOSL;      # Store with optional repeat
INSB_OR  := OREPS INSB;       # I/O input with optional repeat
INSW_OR  := OREPS INSW;       # I/O input with optional repeat
INSL_OR  := OREPS INSL;       # I/O input with optional repeat

# All repeated string instructions
STRS_R[X]
            *1* %SKIP := (%ecx = 0);

CMPSB_OR[X]
            *8* tmpb := m[%esi]{8} - m[%edi]{8};
LODSB_OR[X]
            *8* %al := m[%esi]{8};
MOVSB_OR[X]
            *8* m[%edi] := m[%esi]{8};
SCASB_OR[X]
            *8* tmpb := %al - m[%edi]{8};
STOSB_OR[X]
            *8* m[%edi] := %al;
INSB_OR[X]
			*8* %al := nondet(8);

STRFLB_OR[X]
            SUBFLAGS8(m[%esi]{8}, m[%edi]{8}, tmpb);
STRSIB[IDX]
            *32* %esi := %esi + [%DF = 0?1:-1];
STRDIB[IDX]
            *32* %edi := %edi + [%DF = 0?1:-1];
            

CMPSW_OR[X] 
            *16* tmph := m[%esi]{16} - m[%edi]{16};
LODSW_OR[X]
            *16* %ax := m[%esi]{16};
MOVSW_OR[X]
            *16* m[%edi] := m[%esi]{16};
SCASW_OR[X]
            *16* tmph := %ax - m[%edi]{16};
STOSW_OR[X]
            *16* m[%edi] := %ax;
INSW_OR[X]
			*16* %ax := nondet(16);
STRFLW_OR[X]
            SUBFLAGS16(m[%esi]{16}, m[%edi]{16}, tmph);
STRSIW[IDX]
            *32* %esi := %esi + [%DF = 0?2:-2];
STRDIW[IDX]
            *32* %edi := %edi + [%DF = 0?2:-2];


CMPSL_OR[X]   
            *32* tmp1 := m[%esi]{32} - m[%edi]{32};
LODSL_OR[X]   
            *32* %eax := m[%esi]{32};
MOVSL_OR[X]   
            *32* m[%edi] := m[%esi]{32};
SCASL_OR[X]   
            *32* tmp1 := %eax - m[%edi]{32};
STOSL_OR[X]   
            *32* m[%edi] := %eax;
INSL_OR[X]
			*32* %eax := nondet(32);
STRFLL_OR[X]   
            SUBFLAGS32(m[%esi]{32}, m[%edi]{32}, tmp1);
STRSIL[IDX]   
            *32* %esi := %esi + [%DF = 0?4:-4];
STRDIL[IDX]   
            *32* %edi := %edi + [%DF = 0?4:-4];

# All repeated instructions decrement %ecx
STRS_R[X]
            *32* %ecx := %ecx - 1;

# Do the repeat logic
REPIFZ := REP STRFL;
REPIFZ[X]
            *1* %RPT := %ZF;

REPIFNZ := REPNE STRFL;
REPIFNZ[X]
            *1* %RPT := ~%ZF;

REPALL := REPS STRNF;
REPALL[X]
            *1* %RPT := 1;

# End string instructions


TESTB.AL.IB   i8 
            *8* tmpb := %al & i8
            LOGICALFLAGS8(tmpb);

TESTW.EAX.IVOW   i16 
            *16* tmph := %eax & i16
            LOGICALFLAGS16(tmph);

TESTL.EAX.IVOD   i32 
            *32* tmp1 := %eax & i32
            LOGICALFLAGS32(tmp1);

TESTB.EB.IB   modrm, i8 
            *8* tmpb := modrm{8} & i8
            LOGICALFLAGS8(tmpb);

TESTW.EW.IW   modrm, i16 
            *16* tmph := modrm{16} & i16
            LOGICALFLAGS16(tmph);

TESTL.ED.ID   modrm, i32 
            *32* tmp1 := modrm{32} & i32
            LOGICALFLAGS32(tmp1);

TESTB.EV.GB   modrm, reg8 
            *8* tmpb := modrm{8} & reg8
            LOGICALFLAGS8(tmpb);

TESTW.EV.GVOW   modrm, reg16 
            *16* tmph := modrm{16} & reg16
            LOGICALFLAGS16(tmph);

TESTL.EV.GVOD   modrm, reg32 
            *32* tmp1 := modrm{32} & reg32
            LOGICALFLAGS32(tmp1);

WAIT    _ ;

XADDB.EV.GB   modrm, reg8 
            *8* tmpb1 := modrm{8}
            *8* tmpb2 := reg8
            *8* modrm := tmpb1 + reg8
            *8* reg8 := tmpb1
            ADDFLAGS8(tmpb1, tmpb2, modrm);

XADDW.EV.GVOW   modrm, reg16 
            *16* tmph1 := modrm{16}
            *16* tmph2 := reg16
            *16* modrm := tmph1 + reg16
            *16* reg16 := tmph1
            ADDFLAGS16(tmph1, tmph2, modrm);

XADDL.EV.GVOD   modrm, reg32 
            *32* tmp1 := modrm{32}
            *32* tmp2 := reg32
            *32* modrm := tmp1 + reg32
            *32* reg32 := tmp1
            ADDFLAGS32(tmp1, tmp2, modrm);

XCHGL.EAXOD   reg32 
            *32* tmp1 := reg32
            *32* reg32 := %eax
            *32* %eax := tmp1;

XCHGW.AXOW   reg16 
            *16* tmph := reg16
            *16* reg16 := %ax
            *16* %ax := tmph;

XCHGB.EB.GB   modrm, reg8 
            *8* tmpb := modrm{8}
            *8* modrm := reg8
            *8* reg8 := tmpb;

XCHGW.EV.GVOW   modrm, reg16 
            *16* tmph := modrm{16}
            *16* modrm := reg16
            *16* reg16 := tmph;

XCHGL.EV.GVOD   modrm, reg32 
            *32* tmp1 := modrm{32}
            *32* modrm := reg32
            *32* reg32 := tmp1;

#
# Start of Floating point operators
#

FPUSH()  {
            *f80* %st3 := %st2
            *f80* %st2 := %st1
            *f80* %st1 := %st0
};

FPOP()  {
            *f80* %st0 := %st1
            *f80* %st1 := %st2
            *f80* %st2 := %st3
};

F2XM1
            # Compute (2^x)-1
            # Note: pwr is the binary "raise to power of" operator
            *f80* %st0 := (2.0 pow %st0) -f 1.0;

FABS    
            *f80* %st0 := fabs(%st0);

OP3 := { "+f", "-f" };
FARIT := { "FADD", "FSUB" };

FADDS.r32 modrm 
            *f80* %st0 := %st0 +f fsize(32,80,modrm);

FSUBS.r32 modrm 
            *f80* %st0 := %st0 -f fsize(32,80,modrm);

FADDL.r64	modrm
            *f80* %st0 := %st0 +f fsize(64,80,modrm);

FSUBL.r64	modrm
			*f80* %st0 := %st0 -f fsize(64,80,modrm);

FARIT[IDX].ST.STi sti
            *f80* %st0 := %st0 OP3[IDX] sti;

FARIT[IDX].STi.ST sti 
            *f80* sti := sti OP3[IDX] %st0;

FARITP := { "FADDP", "FSUBP" };

FADDPS.r32 modrm 
            *f80* %st0 := %st0 +f fsize(32,80,modrm)
            FPOP();

FSUBPS.r32 modrm 
            *f80* %st0 := %st0 -f fsize(32,80,modrm)
            FPOP();

FADDPL.r64 modrm 
            *f80* %st0 := %st0 +f fsize(64,80,modrm)
            FPOP();

FSUBPL.r64 modrm 
            *f80* %st0 := %st0 -f fsize(64,80,modrm)
            FPOP();

FARITP[IDX].ST.STi sti 
            *f80* %st0 := %st0 OP3[IDX] sti
            FPOP();

FARITP[IDX].STi.ST sti 
            *f80* sti := sti OP3[IDX] %st0
            FPOP();

FIADD.i16   modrm 
            *f80* %st0 := %st0 +f itof(16,80,modrm);

FIADDL.i32   modrm 
            *f80* %st0 := %st0 +f itof(32,80,modrm);

FCHS    
            *f80* %st0 := ~f %st0;

FCLEX    
            *8* %fsw@[0:7] := 0
            *1* %fsw@[15:15] := 0;

FNCLEX    
            *8* %fsw@[0:7] := 0
            *1* %fsw@[15:15] := 0;

FCOMS.r32    modrm 
            *f80* tmpD := %st0 -f fsize(32,80,modrm)
            SETFFLAGS(%st0, fsize(32,80,modrm));

FCOML.r64    modrm 
            *f80* tmpD := %st0 -f fsize(64,80,modrm)
            SETFFLAGS(%st0, fsize(64,80,modrm));

FCOM.ST.STi sti 
            *f80* tmpD := %st0 -f sti
            SETFFLAGS(%st0, sti);

FCOMPS.r32   modrm 
            # Note that the FPOP() will actually change the register numbers!
            *f80* tmpD1 := %st0
            *f80* tmpD2 := fsize(32, 80, modrm)
            *f80* tmpD := %st0 -f fsize(32,80,modrm)
            FPOP()
            SETFFLAGS(tmpD1, tmpD2);

FCOMPL.r64   modrm 
            *f80* tmpD1 := %st0
            *f80* tmpD2 := fsize(64, 80, modrm)
            *f80* tmpD := %st0 -f fsize(64,80,modrm)
            FPOP()
            SETFFLAGS(tmpD1, tmpD2);

FCOMP.ST.STi   sti 
            *f80* tmpD1 := %st0
            *f80* tmpD2 := sti
            *f80* tmpD := %st0 -f sti
            FPOP()
            SETFFLAGS(tmpD1, tmpD2);
FCOMPP    
            *f80* tmpD1 := %st0
            *f80* tmpD2 := %st1
            *f80* tmpD := %st0 -f %st1
            FPOP()
            FPOP()
            SETFFLAGS(tmpD1, tmpD2);

FCOS    
            *f80* %st0 := cos(%st0);

FDIVS.r32   modrm 
            *f80* %st0 := %st0 /f fsize(32,80,modrm);

FDIVL.r64   modrm 
            *f80* %st0 := %st0 /f fsize(64,80,modrm);

FDIV.ST.STi   sti 
            *f80* %st0 := %st0 /f sti;

# At this point, it should be noted that Intel have an unusual way of
# defining what is and isn't an "R" (reverse operands) instruction.
# Beware! Many disassemblers and assemblers get it wrong.
# Of course, gcc uses "AT&T" syntax, so that makes it more confusing again.
# Note that the decoder now gets the names right, as per the Intel manual.
# Note: some older Intel manuals have errors in the FSUB and FSUBR
# instructions.

FDIV.STi.ST   sti 
            *f80* sti := sti /f %st0;

FDIVP.STi.ST   sti 
            *f80* sti := sti /f %st0
            FPOP();

FIDIVL.i32   modrm 
            *f80* %st0 := %st0 /f itof(32,80,modrm);

FIDIV.i16   modrm 
            *f80* %st0 := %st0 /f itof(16,80,modrm);

FDIVRS.r32   modrm 
            *f80* %st0 := fsize(32,80,modrm) /f %st0;

FDIVRL.r64   modrm 
            *f80* %st0 := fsize(64,80,modrm) /f %st0;

FDIVR.ST.STi   sti 
            *f80* %st0 := sti /f %st0;

FDIVR.STi.ST   sti 
            *f80* sti := %st0 /f sti;

FDIVRP.STi.ST   sti 
            *f80* sti := %st0 /f sti
            FPOP();

FIDIVRL.i32   modrm 
            *f80* %st0 := itof(32,80,modrm) /f %st0;

FIDIVR.i16   modrm 
            *f80* %st0 := itof(16,80,modrm) /f %st0;

FICOM.i16   modrm 
            *f80* tmpD := %st0 -f itof(16,80,modrm)
            SETFFLAGS(%st0, itof(16,80,modrm));

FICOML.i32   modrm 
            *f80* tmpD := %st0 -f itof(32,80,modrm)
            SETFFLAGS(%st0, itof(32,80,modrm));

FICOMP.i16   modrm 
            *f80* tmpD := %st0 -f itof(16,80,modrm)
            FPOP()
            SETFFLAGS(%st0, itof(16,80,modrm));

FICOMPL.i32   modrm 
            *f80* tmpD := %st0 -f itof(32,80,modrm)
            FPOP()
            SETFFLAGS(%st0, itof(32,80,modrm));

FILD.lsI16   modrm 
            FPUSH()
            *f80* %st0 := itof(16,80,modrm);

FILDL.lsI32   modrm 
            FPUSH()
            *f80* %st0 := itof(32,80,modrm);

FILDLL.lsI64   modrm 
            FPUSH()
            *f80* %st0 := itof(64,80,modrm);

FINCSTP    
            FPUSH();

FINIT
            _ ;               # No operation; may find in startup code

FIST   modrm 
            *16* modrm := ftoi(80,16,%st0);

FISTL   modrm 
            *32* modrm := ftoi(80,32,%st0);

FISTP   modrm 
            *16* modrm := ftoi(80,16,%st0)
            FPOP();

FISTPL   modrm 
            *32* modrm := ftoi(80,32,%st0)
            FPOP();

FISTPLL   modrm 
            *64* modrm := ftoi(80,64,%st0)
            FPOP();

FLDS   modrm 
            FPUSH()
            *f80* %st0 := fsize(32,80,modrm{32});

FLDL   modrm 
            FPUSH()
            *f80* %st0 := fsize(64,80,modrm{64});

FLDT   modrm 
            FPUSH()
            *f80* %st0 := modrm{80};

FLD.STi     sti
			*f80* tmpD := sti 
            FPUSH()
            *f80* %st0 := tmpD;

FLD1    
            FPUSH()
            *f80* %st0 := 1.0;

FLDL2T    
            FPUSH()
            *f80* %st0 := log2(10.0);

FLDL2E    
            FPUSH()
            *f80* %st0 := log2(2.7182818);

FLDPI    
            FPUSH()
            *f80* %st0 := 3.1415926;

FLDLG2    
            FPUSH()
            *f80* %st0 := log10(2.0);

FLDLN2    
            FPUSH()
            *f80* %st0 := loge(2.0);

FLDZ    
            FPUSH()
            *f80* %st0 := 0.0;

FLDCW   modrm 
            *16* %fcw := modrm;

FMULS.r32   modrm 
            *f80* %st0 := %st0 *f fsize(32,80,modrm);

FMULL.r64   modrm 
            *f80* %st0 := %st0 *f fsize(64,80,modrm);

FMUL.ST.STi   sti 
            *f80* %st0 := %st0 *f sti;

FMUL.STi.ST   sti 
            *f80* sti := %st0 *f sti;

FMULP.STi.ST   sti 
            *f80* sti := %st0 *f sti
            FPOP();

FIMUL.i16   modrm 
            *f80* %st0 := %st0 *f itof(16,80,modrm);

FIMULL.i32   modrm 
            *f80* %st0 := %st0 *f itof(32,80,modrm);

FNOP    _ ;

FPATAN    
            *f80* %st1 := arctan(%st1 /f %st0)
            FPOP();

# FPREM is for backwards compatibility with 80{2}87 FPUs
FPREM
            *f80* tmpD := ftrunc(%st0 /f %st1)   # Should chop towards 0
            *f80* %st0 := %st0 -f (%st1 *f tmpD)
# If st1 was/is negative, we need to change the sign of st0?
            *f80* %st0 := [%st1 < 0 ? ~f %st0 : %st0];
            #*1* %C2 := 0
            #*1* %FZF := bit 2 of tmpD as integer  # %C0 is %FZF
            #*1* %FLF := bit 1 of tmpD as integer  # %C3 is %FLF
            #*1* %C1  := bit 0 of tmpD as integer

# Floating point remainder.
FPREM1
            *f80* tmpD := ftrunc(%st0 /f %st1)   # Should round to nearest
            *f80* %st0 := %st0 -f (%st1 *f tmpD);
            #*1* %C2 := 0
            #*1* %FZF := bit 2 of tmpD as integer  # %C0 is %FZF
            #*1* %FLF := bit 1 of tmpD as integer  # %C3 is %FLF
            #*1* %C1  := bit 0 of tmpD as integer

FPTAN    
            *f80* %st0 := tan(%st0)
            FPUSH()
            *f80* %st0 := 1.0;

FRNDINT    
            *f80* %st0 := fround(80,80,%st0);

FSCALE      # Raise 2 to an integer power and multiply
            # Note that st1 is "chopped" before use
            *f80* %st0 := %st0 *f (2.0 pow ftrunc(%st1));

FSIN    
            *f80* %st0 := sin(%st0);

FSINCOS    
            *f80* tmpD := %st0
            *f80* %st0 := sin(tmpD)
            FPUSH()
            *f80* %st0 := cos(tmpD);

FSQRT    
            *f80* %st0 := sqrt(%st0);

FSTS   modrm 
            *32* modrm := fsize(80,32,%st0);

FSTL   modrm 
            *64* modrm := fsize(80,64,%st0);

FST   sti 
            *f80* sti := %st0;

FSTPS   modrm 
            *32* modrm := fsize(80,32,%st0)
            FPOP();

FSTPL   modrm 
            *64* modrm := fsize(80,64,%st0)
            FPOP();

FSTPT   modrm 
            *f80* modrm := %st0
            FPOP();

FSTP   sti 
            *f80* sti := %st0
            FPOP();

FSTCW   modrm 
            *16* modrm := %fcw;

FNSTCW   modrm 
            *16* modrm := %fcw;

FSTSW   modrm 
            *16* modrm := %fsw;

FSTSW.AX    
            *16* %ax := %fsw;

FNSTSW   modrm 
            *16* modrm := %fsw;

FNSTSW.AX    
            *16* %ax := %fsw;

FSUBRS.r32   modrm 
            *f80* %st0 := fsize(32,80,modrm) -f %st0;

FSUBRL.r64   modrm 
            *f80* %st0 := fsize(64,80,modrm) -f %st0;

FSUBR.ST.STi   sti 
            *f80* %st0 := sti -f %st0;

# We used to think this one had to be swapped
FSUBR.STi.ST   sti 
            *f80* sti := %st0 -f sti;

# We used to think this one had to be swapped
FSUBRP.STi.ST   sti 
            *f80* sti := %st0 -f sti
            FPOP();

FISUBL.i32   modrm 
            *f80* %st0 := %st0 -f itof(32,80,modrm);

FISUB.i16   modrm 
            *f80* %st0 := %st0 - itof(16,80,modrm);

FISUBRL.i32   modrm 
            *f80* %st0 := itof(32,80,modrm) -f %st0;

FISUBR.i16   modrm 
            *f80* %st0 := itof(16,80,modrm) -f %st0;

FTST    
            SETFFLAGS(%st0, 0.0);

FUCOM       sti 
            *f80* tmpD := %st0 -f sti
            SETFFLAGS(%st0, sti);

FUCOMI.ST.STi	sti 
			*f80* tmpD := %st0 -f sti
			SUBFLAGSFL(%st0, sti);

FUCOMP      sti 
            *f80* tmpD1 := %st0
            *f80* tmpD2 := sti
            *f80* tmpD := %st0 -f sti
            FPOP()
            SETFFLAGS(tmpD1, tmpD2);

FUCOMIP.ST.STi	sti 
            *f80* tmpD1 := %st0
            *f80* tmpD2 := sti
            *f80* tmpD := %st0 -f sti
            FPOP()
            SUBFLAGSFL(tmpD1, tmpD2);

FUCOMPP    
            *f80* tmpD1 := %st0
            *f80* tmpD2 := %st1
            *f80* tmpD := %st0 -f %st1
            FPOP()
            FPOP()
            SETFFLAGS(tmpD1, tmpD2);

FWAIT    _ ;

FXCH        sti 
            *f80* tmpD := %st0
            *f80* %st0 := sti
            *f80* sti := tmpD;

FYL2X    
            *f80* %st1 := %st1 *f log2(%st0)
            FPOP();

FYL2XP1    
            *f80* %st1 := %st1 *f log2(%st0 +f 1.0)
            FPOP();

# SSE Instructions

LDMXCSR    modrm
			*32* %stmxcsr := modrm{32};
			
STMXCSR    modrm
			*32* modrm := %stmxcsr;

CVTSI2SS	reg128, modrm
			*32* reg128@[0:31] := itof(32,32,modrm);			
			
CVTSI2SD	reg128, modrm
			*64* reg128@[0:63] := itof(32,64,modrm{32});
			
# All CVTT instructions really truncate and don't round 			
CVTTSD2SI	reg32, modrm
			*32* reg32 := ftoi(64,32,modrm{128}@[0:63]);
			
CVTTSS2SI	reg32, modrm
			*32* reg32 := ftoi(32,32,modrm{128}@[0:31]);
			
CVTSS2SD	reg128, modrm
			*64* reg128@[0:63] := fsize(32,64,modrm{128}@[0:31]);
			
CVTSD2SS	reg128, modrm
			*32* reg128@[0:31] := fsize(64,32,modrm{128}@[0:63]);
			
MOVD.RM		reg128, modrm
			*128* reg128 := zfill(32,127,modrm{32});
			
MOVD.MR		modrm, reg128
			*32* modrm := reg128@[0:31];

# Simplification. According to Intel spec, for memory source operands,
# the higher 96/64 bits of the target xmm register are set to 0.
MOVSS.RM	reg128, modrm
			*32* reg128@[0:31] := modrm{128}@[0:31]; 

MOVSS.MR	modrm, reg128
			*32* modrm@[0:31] := reg128@[0:31];

MOVSD.RM	reg128, modrm
			*64* reg128@[0:63] := modrm{128}@[0:63]; 

MOVSD.MR	modrm, reg128
			*64* modrm@[0:63] := reg128@[0:63];
			
SMOV := {"MOVDQ", "MOVDQA", "MOVAPS", "MOVAPD", "MOVUPS", "MOVUPD"};

SMOV[IDX]^"MR"	modrm, reg128
			*128* modrm := reg128;
			
SMOV[IDX]^"MR"	reg128, modrm
			*128* reg128 := modrm{128};
			

SOPA := { "+f", "-f", "*f", "/f" };
SARITH_SS := { "ADDSS", "SUBSS", "MULSS", "DIVSS" };
SARITH_SD := { "ADDSD", "SUBSD", "MULSD", "DIVSD" };
SARITH_PS := { "ADDPS", "SUBPS", "MULPS", "DIVPS" };
SARITH_PD := { "ADDPD", "SUBPD", "MULPD", "DIVPD" };

SARITH_SS[IDX] reg128, modrm
            *32* reg128@[0:31] := reg128@[0:31] SOPA[IDX] modrm{128}@[0:31];

SARITH_SD[IDX] reg128, modrm
			*64* reg128@[0:63] := reg128@[0:63] SOPA[IDX] modrm{128}@[0:63];

SARITH_PS[IDX] reg128, modrm
            *32* reg128@[0:31] := reg128@[0:31] SOPA[IDX] modrm{128}@[0:31]
            *32* reg128@[32:63] := reg128@[32:63] SOPA[IDX] modrm{128}@[32:63]
            *32* reg128@[64:95] := reg128@[64:95] SOPA[IDX] modrm{128}@[64:95]
            *32* reg128@[96:127] := reg128@[96:127] SOPA[IDX] modrm{128}@[96:127];

SARITH_PD[IDX] reg128, modrm
			*64* reg128@[0:63] := reg128@[0:63] SOPA[IDX] modrm{128}@[0:63]
			*64* reg128@[64:127] := reg128@[64:127] SOPA[IDX] modrm{128}@[64:127];
			

SQRTSS 	reg128, modrm
            *32* reg128@[0:31] := sqrt(modrm{128}@[0:31]);

SQRTSD 	reg128, modrm
			*64* reg128@[0:63] := sqrt(modrm{128}@[0:63]);

SQRTPS 	reg128, modrm
            *32* reg128@[0:31] := sqrt(modrm{128}@[0:31])
            *32* reg128@[32:63] := sqrt(modrm{128}@[32:63])
            *32* reg128@[64:95] := sqrt(modrm{128}@[64:95])
            *32* reg128@[96:127] := sqrt(modrm{128}@[96:127]);

SQRTPD 	reg128, modrm
			*64* reg128@[0:63] := sqrt(modrm{128}@[0:63])
			*64* reg128@[64:127] := sqrt(modrm{128}@[64:127]);

MINMAXSS	:=	{ "MAXSS", "MINSS" };
MINMAXSD	:=	{ "MAXSD", "MINSD" };
MINMAXPS	:=	{ "MAXPS", "MINPS" };
MINMAXPD	:=	{ "MAXPD", "MINPD" };
GTLT := { ">", "<" };

MINMAXSS[IDX] 	reg128, modrm
            *32* reg128@[0:31] := [ modrm{128}@[0:31] GTLT[IDX] reg128@[0:31] ? modrm{128}@[0:31] : reg128@[0:31]];

MINMAXSD[IDX]	reg128, modrm
            *64* reg128@[0:63] := [ modrm{128}@[0:63] GTLT[IDX] reg128@[0:63] ? modrm{128}@[0:63] : reg128@[0:63]];

MINMAXPS[IDX]	reg128, modrm
            *32* reg128@[0:31] := [ modrm{128}@[0:31] GTLT[IDX] reg128@[0:31] ? modrm{128}@[0:31] : reg128@[0:31]]
            *32* reg128@[32:63] := [ modrm{128}@[32:63] GTLT[IDX] reg128@[32:63] ? modrm{128}@[32:63] : reg128@[32:63]]
            *32* reg128@[64:95] := [ modrm{128}@[64:95] GTLT[IDX] reg128@[64:95] ? modrm{128}@[64:95] : reg128@[64:95]]
            *32* reg128@[96:127] := [ modrm{128}@[96:127] GTLT[IDX] reg128@[96:127] ? modrm{128}@[96:127] : reg128@[96:127]];

MINMAXPD[IDX]	reg128, modrm
            *64* reg128@[0:63] := [ modrm{128}@[0:63] GTLT[IDX] reg128@[0:63] ? modrm{128}@[0:63] : reg128@[0:63]]
            *64* reg128@[64:127] := [ modrm{128}@[64:127] GTLT[IDX] reg128@[64:127] ? modrm{128}@[64:127] : reg128@[64:127]];


# Bitwise SSE operations are all logically equivalent - but different
# opcodes nonetheless
SOPL := { "&", "|", "^"};
SLOG_PS := { "ANDPS", "ORPS", "XORPS"};
SLOG_PD := { "ANDPD", "ORPD", "XORPD"};
PSLOG   := { "PAND", "POR", "PXOR"};

SLOG_PS[IDX]	reg128, modrm
			*128* reg128 := reg128 SOPL[IDX] modrm{128}; 

SLOG_PD[IDX]	reg128, modrm
			*128* reg128 := reg128 SOPL[IDX] modrm{128}; 

PSLOG[IDX]	reg128, modrm
			*128* reg128 := reg128 SOPL[IDX] modrm{128}; 

# Logical AND NOT
ANDNPS			reg128, modrm
			*128* reg128 := ~reg128 & modrm{128};			

ANDNPD			reg128, modrm
			*128* reg128 := ~reg128 & modrm{128};			

PANDN			reg128, modrm
			*128* reg128 := ~reg128 & modrm{128};			
		
# No NaN support (not supported anywhere anyway)
UCOMISS	reg128, modrm
            *1* %ZF := reg128@[0:31] = modrm{128}@[0:31]
            *1* %CF := reg128@[0:31] < modrm{128}@[0:31]
            *1* %OF := 0
            *1* %SF := 0;
            # *1* %AF := 0

UCOMISD	reg128, modrm
            *1* %ZF := reg128@[0:63] = modrm{128}@[0:63]
            *1* %CF := reg128@[0:63] < modrm{128}@[0:63]
            *1* %OF := 0
            *1* %SF := 0;
            # *1* %AF := 0
			